{"file_contents":{"index.js":{"content":"const { Client, GatewayIntentBits, Collection, SlashCommandBuilder, PermissionFlagsBits, EmbedBuilder, ChannelType, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle, Events, AttachmentBuilder, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js');\nconst sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\nconst fs = require('fs');\nrequire('dotenv').config();\n\n// Configuration\nconst config = {\n    guildId: \"1407656756779155477\",\n    ticketChannelId: \"1407656785564930068\",\n    logsChannelId: \"1407656810453663754\",\n    adminRoleId: \"1407657166114127962\",\n    feedbackChannelId: \"1407668519990067200\",\n    ticketCategoryId: null,\n    maxTicketsPerUser: 1,\n    autoDeleteAfterClose: 5000,\n    transcriptChannelId: null\n};\n\n// Database setup\nconst dbPath = path.join(__dirname, 'tickets.db');\nlet db = null;\n\nfunction initializeDatabase() {\n    return new Promise((resolve, reject) => {\n        db = new sqlite3.Database(dbPath, (err) => {\n            if (err) {\n                console.error('Error opening database:', err);\n                reject(err);\n                return;\n            }\n            \n            console.log('Connected to SQLite database');\n            \n            // Create tables if they don't exist\n            db.serialize(() => {\n                // Tickets table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS tickets (\n                        id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        user_id TEXT NOT NULL,\n                        category TEXT NOT NULL,\n                        claimed_by TEXT DEFAULT NULL,\n                        status TEXT DEFAULT 'open',\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                        closed_at DATETIME DEFAULT NULL\n                    )\n                `);\n                \n                // Ticket panels table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS ticket_panels (\n                        guild_id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        message_id TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n                \n                // Transcripts table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS transcripts (\n                        ticket_id TEXT PRIMARY KEY,\n                        content TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n                \n                // Feedback table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS feedback (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        ticket_id TEXT NOT NULL,\n                        user_id TEXT NOT NULL,\n                        rating INTEGER,\n                        comment TEXT,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n            });\n            \n            resolve();\n        });\n    });\n}\n\n// Database functions\nfunction createTicketDB(ticketId, channelId, userId, category) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT INTO tickets (id, channel_id, user_id, category)\n            VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([ticketId, channelId, userId, category], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM tickets WHERE channel_id = ? AND status = 'open'\n        `, [channelId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\nfunction getAllOpenTickets() {\n    return new Promise((resolve, reject) => {\n        db.all(`\n            SELECT * FROM tickets WHERE status = 'open'\n        `, [], (err, rows) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(rows);\n            }\n        });\n    });\n}\n\nfunction claimTicket(channelId, adminId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET claimed_by = ? WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([adminId, channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction closeTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET status = 'closed', closed_at = CURRENT_TIMESTAMP \n            WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction saveTicketPanel(guildId, channelId, messageId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO ticket_panels (guild_id, channel_id, message_id)\n            VALUES (?, ?, ?)\n        `);\n        \n        stmt.run([guildId, channelId, messageId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction saveTranscript(ticketId, content) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO transcripts (ticket_id, content)\n            VALUES (?, ?)\n        `);\n        \n        stmt.run([ticketId, content], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction updateTicketCategory(channelId, newCategory) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET category = ? WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([newCategory, channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction saveFeedback(ticketId, userId, rating, comment) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT INTO feedback (ticket_id, user_id, rating, comment)\n            VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([ticketId, userId, rating, comment], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\n// Ticket categories\nconst TICKET_CATEGORIES = {\n    'general_query': {\n        label: 'General Support',\n        description: 'General questions and support',\n        emoji: 'üîß'\n    },\n    'account_issues': {\n        label: 'Account Issues',\n        description: 'Problems with your account',\n        emoji: 'üìß'\n    },\n    'business_ticket': {\n        label: 'Business Ticket',\n        description: 'Business-related inquiries',\n        emoji: 'üíº'\n    },\n    'membership_ticket': {\n        label: 'Membership Ticket',\n        description: 'Membership support and questions',\n        emoji: 'üëë'\n    },\n    'staff_application': {\n        label: 'Staff Application',\n        description: 'Apply to join our staff team',\n        emoji: 'üìù'\n    },\n    'report': {\n        label: 'Report',\n        description: 'Report users or issues',\n        emoji: '‚ö†Ô∏è'\n    },\n    'billing': {\n        label: 'Billing Support',\n        description: 'Payment and billing issues',\n        emoji: 'üí≥'\n    }\n};\n\n// HTML Transcript Generator\nfunction generateHTMLTranscript(ticket, messages, guild, closedBy) {\n    const categoryInfo = TICKET_CATEGORIES[ticket.category];\n    const categoryLabel = categoryInfo ? categoryInfo.label : 'Unknown';\n    \n    const messagesHTML = messages.map(msg => {\n        const timestamp = msg.createdAt.toLocaleString();\n        const author = msg.author.tag;\n        const avatar = msg.author.displayAvatarURL();\n        const content = msg.content || '[No text content]';\n        const isBot = msg.author.bot ? 'bot-message' : 'user-message';\n        \n        return `\n        <div class=\"message ${isBot}\">\n            <img src=\"${avatar}\" alt=\"${author}\" class=\"avatar\">\n            <div class=\"message-content\">\n                <div class=\"message-header\">\n                    <span class=\"author\">${author}</span>\n                    <span class=\"timestamp\">${timestamp}</span>\n                </div>\n                <div class=\"message-text\">${content}</div>\n            </div>\n        </div>`;\n    }).join('\\\\n');\n\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Ticket Transcript - ${ticket.id}</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: #36393f;\n            color: #dcddde;\n            line-height: 1.6;\n        }\n        \n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        \n        .header {\n            background: #2f3136;\n            padding: 20px;\n            border-radius: 8px;\n            margin-bottom: 20px;\n            border-left: 4px solid #5865f2;\n        }\n        \n        .header h1 {\n            color: #5865f2;\n            margin-bottom: 10px;\n        }\n        \n        .info-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 15px;\n            margin-top: 15px;\n        }\n        \n        .info-item {\n            background: #40444b;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        \n        .info-label {\n            color: #b9bbbe;\n            font-size: 12px;\n            text-transform: uppercase;\n            margin-bottom: 5px;\n        }\n        \n        .info-value {\n            color: #ffffff;\n            font-weight: 500;\n        }\n        \n        .messages {\n            background: #2f3136;\n            border-radius: 8px;\n            padding: 20px;\n        }\n        \n        .message {\n            display: flex;\n            margin-bottom: 15px;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        \n        .user-message {\n            background: #40444b;\n        }\n        \n        .bot-message {\n            background: #36393f;\n            border-left: 3px solid #5865f2;\n        }\n        \n        .avatar {\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            margin-right: 15px;\n        }\n        \n        .message-content {\n            flex: 1;\n        }\n        \n        .message-header {\n            display: flex;\n            align-items: center;\n            margin-bottom: 5px;\n        }\n        \n        .author {\n            font-weight: 600;\n            color: #ffffff;\n            margin-right: 10px;\n        }\n        \n        .timestamp {\n            font-size: 12px;\n            color: #72767d;\n        }\n        \n        .message-text {\n            color: #dcddde;\n            word-wrap: break-word;\n        }\n        \n        .footer {\n            text-align: center;\n            margin-top: 30px;\n            padding: 20px;\n            background: #2f3136;\n            border-radius: 8px;\n            color: #72767d;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>üé´ Ticket Transcript</h1>\n            <div class=\"info-grid\">\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Ticket ID</div>\n                    <div class=\"info-value\">${ticket.id}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Category</div>\n                    <div class=\"info-value\">${categoryLabel}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Created</div>\n                    <div class=\"info-value\">${new Date(ticket.created_at).toLocaleString()}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Closed</div>\n                    <div class=\"info-value\">${new Date().toLocaleString()}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Closed By</div>\n                    <div class=\"info-value\">${closedBy.user.tag}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Server</div>\n                    <div class=\"info-value\">${guild.name}</div>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"messages\">\n            <h2 style=\"margin-bottom: 20px; color: #ffffff;\">üí¨ Conversation</h2>\n            ${messagesHTML}\n        </div>\n        \n        <div class=\"footer\">\n            <p>Generated on ${new Date().toLocaleString()}</p>\n            <p>PCRP Ticket System - Discord Bot</p>\n        </div>\n    </div>\n</body>\n</html>`;\n}\n\n// Embed functions\nfunction createTicketPanelEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üéüÔ∏è Support Tickets')\n        .setDescription(\n            'Please choose the option that best matches your issue from the menu below.\\n' +\n            'Once you select, ‚úÖ a private ticket channel will be created where our team can assist you.\\n\\n' +\n            '‚ú® **How it works:**\\n' +\n            '‚Ä¢ Pick a category from the menu ‚¨áÔ∏è\\n' +\n            '‚Ä¢ A new ticket will open üìÇ\\n' +\n            '‚Ä¢ Our staff will reply as soon as possible ‚è≥'\n        )\n        .setColor(0x5865F2)\n        .setTimestamp();\n}\n\nfunction createTicketEmbed(user, categoryInfo) {\n    return new EmbedBuilder()\n        .setTitle(`üé´ New Ticket - ${categoryInfo.label}`)\n        .setDescription(\n            `Hello ${user.toString()}!\\n\\n` +\n            `Thank you for creating a ticket. Please describe your issue in detail and our support team will assist you shortly.\\n\\n` +\n            `**Category:** ${categoryInfo.label}\\n` +\n            `**Created:** <t:${Math.floor(Date.now() / 1000)}:F>`\n        )\n        .setColor(0x00FF00)\n        .setThumbnail(user.displayAvatarURL())\n        .setTimestamp();\n}\n\nfunction createTicketControlsEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üîß Staff Management Panel')\n        .setDescription(\n            '**For Support Staff:**\\n' +\n            'üî∑ Click **Claim Ticket** to assign yourself to this ticket\\n' +\n            'üî∑ Click **Close Ticket** to close and archive this ticket\\n\\n' +\n            '**For User:**\\n' +\n            'üî∑ You can also close your ticket using the **Close Ticket** button'\n        )\n        .setColor(0x0099FF)\n        .setTimestamp();\n}\n\n// Ticket management functions\nasync function createTicketPanel(channel, guild) {\n    try {\n        // Clear existing messages in the channel\n        const messages = await channel.messages.fetch({ limit: 100 });\n        if (messages.size > 0) {\n            await channel.bulkDelete(messages).catch(console.error);\n        }\n        \n        // Create select menu options\n        const options = Object.entries(TICKET_CATEGORIES).map(([value, category]) => ({\n            label: category.label,\n            description: category.description,\n            value: value,\n            emoji: category.emoji\n        }));\n        \n        const selectMenu = new StringSelectMenuBuilder()\n            .setCustomId('ticket_category')\n            .setPlaceholder('Select the option that best fits your problem...')\n            .addOptions(options);\n        \n        const row = new ActionRowBuilder()\n            .addComponents(selectMenu);\n        \n        const embed = createTicketPanelEmbed();\n        \n        const message = await channel.send({\n            embeds: [embed],\n            components: [row]\n        });\n        \n        // Save panel info to database\n        await saveTicketPanel(guild.id, channel.id, message.id);\n        \n        console.log('Ticket panel created successfully');\n        return true;\n    } catch (error) {\n        console.error('Error creating ticket panel:', error);\n        return false;\n    }\n}\n\nasync function createTicket(guild, user, category) {\n    try {\n        const categoryInfo = TICKET_CATEGORIES[category];\n        if (!categoryInfo) {\n            throw new Error('Invalid ticket category');\n        }\n        \n        // Generate unique ticket ID with category\n        const categoryShortName = {\n            'general_query': 'general',\n            'account_issues': 'account',\n            'business_ticket': 'business',\n            'membership_ticket': 'membership',\n            'staff_application': 'staff',\n            'report': 'report',\n            'billing': 'billing'\n        }[category] || 'general';\n        \n        const ticketId = `pcrp-${user.username}-${categoryShortName}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        // Get admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        \n        // Create ticket channel with restricted permissions\n        const ticketChannel = await guild.channels.create({\n            name: ticketId,\n            type: ChannelType.GuildText,\n            topic: `Ticket for ${user.tag} (${user.id}) - Category: ${categoryInfo.label}`,\n            permissionOverwrites: [\n                {\n                    id: guild.roles.everyone,\n                    deny: [PermissionFlagsBits.ViewChannel]\n                },\n                {\n                    id: user.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.SendMessages,\n                        PermissionFlagsBits.ReadMessageHistory\n                    ]\n                },\n                ...(adminRole ? [{\n                    id: adminRole.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.ReadMessageHistory,\n                        PermissionFlagsBits.ManageMessages\n                    ],\n                    deny: [PermissionFlagsBits.SendMessages]\n                }] : [])\n            ]\n        });\n        \n        // Create ticket controls\n        const claimButton = new ButtonBuilder()\n            .setCustomId('claim_ticket')\n            .setLabel('Claim Ticket')\n            .setStyle(ButtonStyle.Primary)\n            .setEmoji('üëã');\n        \n        const closeButton = new ButtonBuilder()\n            .setCustomId('close_ticket')\n            .setLabel('Close Ticket')\n            .setStyle(ButtonStyle.Danger)\n            .setEmoji('üîí');\n        \n        const controlRow = new ActionRowBuilder()\n            .addComponents(claimButton, closeButton);\n        \n        // Send ticket message\n        const ticketEmbed = createTicketEmbed(user, categoryInfo);\n        \n        // Send main ticket message for everyone\n        await ticketChannel.send({\n            content: `${user.toString()}${adminRole ? ` ${adminRole.toString()}` : ''}`,\n            embeds: [ticketEmbed]\n        });\n        \n        // Send controls message only visible to admins\n        if (adminRole) {\n            const controlsEmbed = createTicketControlsEmbed();\n            await ticketChannel.send({\n                content: `${adminRole.toString()}`,\n                embeds: [controlsEmbed],\n                components: [controlRow]\n            });\n        }\n        \n        // Save ticket to database\n        await createTicketDB(ticketId, ticketChannel.id, user.id, category);\n        \n        console.log(`Ticket created: ${ticketId} for user ${user.tag}`);\n        return ticketChannel;\n    } catch (error) {\n        console.error('Error creating ticket:', error);\n        return null;\n    }\n}\n\nasync function handleTicketClaim(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to claim tickets.',\n                ephemeral: true\n            });\n        }\n        \n        // Get ticket from database\n        const ticket = await getTicket(channel.id);\n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        if (ticket.claimed_by) {\n            const claimedUser = await guild.members.fetch(ticket.claimed_by).catch(() => null);\n            return await interaction.reply({\n                content: `‚ùå This ticket is already claimed by ${claimedUser ? claimedUser.toString() : 'another admin'}.`,\n                ephemeral: true\n            });\n        }\n        \n        // Claim the ticket\n        await claimTicket(channel.id, member.id);\n        \n        // Give claimer permission to send messages\n        await channel.permissionOverwrites.edit(member.id, {\n            ViewChannel: true,\n            SendMessages: true,\n            ReadMessageHistory: true,\n            ManageMessages: true\n        });\n        \n        await interaction.reply({\n            content: `‚úÖ ${member.toString()} has claimed this ticket!`\n        });\n        \n        console.log(`Ticket ${ticket.id} claimed by ${member.user.tag}`);\n    } catch (error) {\n        console.error('Error claiming ticket:', error);\n        await interaction.reply({\n            content: '‚ùå An error occurred while claiming the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function handleTicketClose(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role or is the ticket creator\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        const ticket = await getTicket(channel.id);\n        \n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        const isAdmin = adminRole && member.roles.cache.has(adminRole.id);\n        const isTicketCreator = ticket.user_id === member.id;\n        \n        if (!isAdmin && !isTicketCreator) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to close this ticket.',\n                ephemeral: true\n            });\n        }\n        \n        await interaction.reply({\n            content: 'üîí Closing ticket and saving transcript...'\n        });\n        \n        // Generate transcript\n        const messages = await channel.messages.fetch({ limit: 100 });\n        const sortedMessages = messages.reverse();\n        \n        // Generate plain text transcript\n        const transcript = sortedMessages.map(msg => \n            `[${msg.createdAt.toISOString()}] ${msg.author.tag}: ${msg.content}`\n        ).join('\\n');\n        \n        // Generate HTML transcript\n        const htmlTranscript = generateHTMLTranscript(ticket, sortedMessages, guild, member);\n        const fileName = `transcript-${ticket.id}.html`;\n        const filePath = path.join(__dirname, fileName);\n        \n        // Save HTML file\n        fs.writeFileSync(filePath, htmlTranscript);\n        \n        // Save transcript to database\n        await saveTranscript(ticket.id, transcript);\n        \n        // Close ticket in database\n        await closeTicket(channel.id);\n        \n        // Get ticket creator for DM and logs\n        const user = await guild.members.fetch(ticket.user_id).catch(() => null);\n        const claimedBy = ticket.claimed_by ? await guild.members.fetch(ticket.claimed_by).catch(() => null) : null;\n        \n        // Create attachment for HTML transcript\n        const attachment = new AttachmentBuilder(filePath, { name: fileName });\n        \n        // Send transcript to logs channel if configured\n        const logsChannel = guild.channels.cache.get(config.logsChannelId);\n        if (logsChannel) {\n            await logsChannel.send({\n                content: `**Ticket Closed**\\n` +\n                        `**Ticket ID:** ${ticket.id}\\n` +\n                        `**Created by:** ${user ? user.toString() : 'Unknown User'}\\n` +\n                        `**Claimed by:** ${claimedBy ? claimedBy.toString() : 'Unclaimed'}\\n` +\n                        `**Closed by:** ${member.toString()}\\n` +\n                        `**Category:** ${ticket.category}\\n` +\n                        `**Created:** ${ticket.created_at}\\n` +\n                        `**Closed:** ${new Date().toISOString()}`,\n                files: [attachment]\n            });\n        }\n        \n        // Send transcript copy to ticket creator via DM\n        if (user) {\n            try {\n                const categoryInfo = TICKET_CATEGORIES[ticket.category];\n                const userAttachment = new AttachmentBuilder(filePath, { name: fileName });\n                \n                // Create feedback buttons\n                const star1 = new ButtonBuilder()\n                    .setCustomId(`feedback_1_${ticket.id}`)\n                    .setLabel('1‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star2 = new ButtonBuilder()\n                    .setCustomId(`feedback_2_${ticket.id}`)\n                    .setLabel('2‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star3 = new ButtonBuilder()\n                    .setCustomId(`feedback_3_${ticket.id}`)\n                    .setLabel('3‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star4 = new ButtonBuilder()\n                    .setCustomId(`feedback_4_${ticket.id}`)\n                    .setLabel('4‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star5 = new ButtonBuilder()\n                    .setCustomId(`feedback_5_${ticket.id}`)\n                    .setLabel('5‚≠ê')\n                    .setStyle(ButtonStyle.Success);\n                \n                const feedbackRow = new ActionRowBuilder()\n                    .addComponents(star1, star2, star3, star4, star5);\n                \n                const textFeedbackButton = new ButtonBuilder()\n                    .setCustomId(`feedback_text_${ticket.id}`)\n                    .setLabel('üìù Add Comment')\n                    .setStyle(ButtonStyle.Primary);\n                \n                const textRow = new ActionRowBuilder()\n                    .addComponents(textFeedbackButton);\n                \n                await user.user.send({\n                    content: `üé´ **Your Support Ticket Transcript**\\n\\n` +\n                            `Hello ${user.user.username}! Your support ticket has been closed.\\n\\n` +\n                            `**Ticket Details:**\\n` +\n                            `‚Ä¢ **Ticket ID:** ${ticket.id}\\n` +\n                            `‚Ä¢ **Category:** ${categoryInfo ? categoryInfo.label : 'Unknown'} ${categoryInfo ? categoryInfo.emoji : ''}\\n` +\n                            `‚Ä¢ **Closed by:** ${member.user.tag}\\n` +\n                            `‚Ä¢ **Date:** ${new Date().toLocaleDateString()}\\n\\n` +\n                            `üìé **Attached:** Complete conversation transcript\\n\\n` +\n                            `üí≠ **How was our support?** Please rate your experience:\\n\\n` +\n                            `Thank you for using PCRP Support! If you need further assistance, feel free to create a new ticket.`,\n                    files: [userAttachment],\n                    components: [feedbackRow, textRow]\n                });\n                \n                console.log(`Transcript DM sent successfully to ${user.user.tag}`);\n            } catch (dmError) {\n                console.log(`Could not send transcript DM to ${user.user.tag}: ${dmError.message}`);\n                // Try to inform in logs channel that DM failed\n                if (logsChannel) {\n                    try {\n                        await logsChannel.send({\n                            content: `‚ö†Ô∏è **DM Failed** - Could not send transcript to ${user.toString()}: ${dmError.message}`\n                        });\n                    } catch (logError) {\n                        console.log('Failed to log DM error:', logError.message);\n                    }\n                }\n            }\n        }\n        \n        // Delete channel after a short delay\n        setTimeout(async () => {\n            try {\n                await channel.delete();\n                console.log(`Ticket channel ${channel.name} deleted`);\n                \n                // Clean up HTML file after sending\n                if (fs.existsSync(filePath)) {\n                    fs.unlinkSync(filePath);\n                    console.log(`Cleaned up transcript file: ${fileName}`);\n                }\n            } catch (error) {\n                console.error('Error deleting ticket channel:', error);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('Error closing ticket:', error);\n        await interaction.followUp({\n            content: '‚ùå An error occurred while closing the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function reconnectToTickets(client, guild) {\n    try {\n        const openTickets = await getAllOpenTickets();\n        let reconnectedCount = 0;\n        \n        for (const ticket of openTickets) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channel_id);\n                if (!channel) {\n                    // Channel doesn't exist, mark ticket as closed\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed orphaned ticket: ${ticket.id}`);\n                    continue;\n                }\n                \n                // Verify channel is still a valid ticket\n                if (!channel.name.startsWith('ticket-')) {\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed invalid ticket channel: ${ticket.id}`);\n                    continue;\n                }\n                \n                reconnectedCount++;\n                console.log(`Reconnected to ticket: ${ticket.id} in channel ${channel.name}`);\n            } catch (error) {\n                console.error(`Error reconnecting to ticket ${ticket.id}:`, error);\n                // Mark as closed if there's an error\n                await closeTicket(ticket.channel_id);\n            }\n        }\n        \n        console.log(`Reconnected to ${reconnectedCount} open tickets`);\n    } catch (error) {\n        console.error('Error during ticket reconnection:', error);\n    }\n}\n\nasync function handleTicketCreation(interaction) {\n    try {\n        const category = interaction.values[0];\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has an open ticket\n        const existingTickets = guild.channels.cache.filter(channel => \n            channel.name.startsWith('ticket-') && \n            channel.topic && \n            channel.topic.includes(user.id)\n        );\n        \n        if (existingTickets.size > 0) {\n            return await interaction.reply({\n                content: '‚ùå You already have an open ticket! Please close your existing ticket before creating a new one.',\n                ephemeral: true\n            });\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        const ticket = await createTicket(guild, user, category);\n        \n        if (ticket) {\n            await interaction.editReply({\n                content: `‚úÖ Your ticket has been created! Please check ${ticket.toString()}`\n            });\n        } else {\n            await interaction.editReply({\n                content: '‚ùå Failed to create ticket. Please try again or contact an administrator.'\n            });\n        }\n    } catch (error) {\n        console.error('Ticket creation error:', error);\n        await interaction.editReply({\n            content: '‚ùå An error occurred while creating your ticket.'\n        });\n    }\n}\n\nasync function handleTicketTransfer(interaction) {\n    try {\n        const newCategory = interaction.values[0];\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Get ticket from database\n        const ticket = await getTicket(channel.id);\n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        const oldCategoryInfo = TICKET_CATEGORIES[ticket.category];\n        const newCategoryInfo = TICKET_CATEGORIES[newCategory];\n        \n        if (!newCategoryInfo) {\n            return await interaction.reply({\n                content: '‚ùå Invalid category selected.',\n                ephemeral: true\n            });\n        }\n        \n        // Update ticket category in database\n        await updateTicketCategory(channel.id, newCategory);\n        \n        // Update channel topic\n        const user = await guild.members.fetch(ticket.user_id).catch(() => null);\n        const newTopic = `Ticket for ${user ? user.user.tag : 'Unknown User'} (${ticket.user_id}) - Category: ${newCategoryInfo.label}`;\n        await channel.setTopic(newTopic);\n        \n        // Generate new channel name with new category\n        const categoryShortName = {\n            'general_query': 'general',\n            'account_issues': 'account', \n            'business_ticket': 'business',\n            'membership_ticket': 'membership',\n            'staff_application': 'staff',\n            'report': 'report',\n            'billing': 'billing'\n        }[newCategory] || 'general';\n        \n        const username = user ? user.user.username : 'unknown';\n        const newChannelName = `pcrp-${username}-${categoryShortName}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        // Rename channel to reflect new category\n        await channel.setName(newChannelName);\n        \n        await interaction.reply({\n            content: `‚úÖ **Ticket Transferred Successfully**\\n\\n` +\n                    `**From:** ${oldCategoryInfo ? oldCategoryInfo.label : 'Unknown'} ${oldCategoryInfo ? oldCategoryInfo.emoji : ''}\\n` +\n                    `**To:** ${newCategoryInfo.label} ${newCategoryInfo.emoji}\\n` +\n                    `**New Channel Name:** ${newChannelName}`\n        });\n        \n        // Send notification message in the ticket\n        await channel.send({\n            content: `üîÑ **Ticket Category Changed**\\n\\n` +\n                    `This ticket has been transferred from **${oldCategoryInfo ? oldCategoryInfo.label : 'Unknown'}** to **${newCategoryInfo.label}** by ${member.toString()}.`\n        });\n        \n        console.log(`Ticket ${ticket.id} transferred from ${ticket.category} to ${newCategory} by ${member.user.tag}`);\n        \n    } catch (error) {\n        console.error('Ticket transfer error:', error);\n        await interaction.reply({\n            content: '‚ùå An error occurred while transferring the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\n// Create Discord client\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMembers\n    ]\n});\n\n// Initialize collections\nclient.commands = new Collection();\n\n// Setup command\nconst setupCommand = {\n    data: new SlashCommandBuilder()\n        .setName('setup')\n        .setDescription('Setup the ticket system in this channel')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            await interaction.deferReply({ ephemeral: true });\n            \n            const success = await createTicketPanel(interaction.channel, interaction.guild);\n            \n            if (success) {\n                await interaction.editReply({\n                    content: '‚úÖ Ticket system has been successfully set up in this channel!'\n                });\n            } else {\n                await interaction.editReply({\n                    content: '‚ùå Failed to set up ticket system. Please try again.'\n                });\n            }\n        } catch (error) {\n            console.error('Setup command error:', error);\n            await interaction.editReply({\n                content: '‚ùå An error occurred while setting up the ticket system.'\n            });\n        }\n    }\n};\n\n// Add user to ticket command\nconst addCommand = {\n    data: new SlashCommandBuilder()\n        .setName('add')\n        .setDescription('Add a user to this ticket')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('The user to add to this ticket')\n                .setRequired(true))\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            const guild = interaction.guild;\n            const member = interaction.member;\n            const channel = interaction.channel;\n            const userToAdd = interaction.options.getUser('user');\n            \n            // Check if user has admin role\n            const adminRole = guild.roles.cache.get(config.adminRoleId);\n            if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n                return await interaction.reply({\n                    content: '‚ùå You do not have permission to add users to tickets.',\n                    ephemeral: true\n                });\n            }\n            \n            // Check if this is a ticket channel\n            const ticket = await getTicket(channel.id);\n            if (!ticket) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            // Add user to ticket channel with messaging permissions\n            await channel.permissionOverwrites.edit(userToAdd.id, {\n                ViewChannel: true,\n                SendMessages: true,\n                ReadMessageHistory: true\n            });\n            \n            await interaction.reply({\n                content: `‚úÖ ${userToAdd.toString()} has been added to this ticket!`\n            });\n            \n            console.log(`User ${userToAdd.tag} added to ticket ${ticket.id} by ${member.user.tag}`);\n            \n        } catch (error) {\n            console.error('Add command error:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while adding the user to this ticket.',\n                ephemeral: true\n            });\n        }\n    }\n};\n\n// Remove user from ticket command\nconst removeCommand = {\n    data: new SlashCommandBuilder()\n        .setName('remove')\n        .setDescription('Remove a user from this ticket')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('The user to remove from this ticket')\n                .setRequired(true))\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            const guild = interaction.guild;\n            const member = interaction.member;\n            const channel = interaction.channel;\n            const userToRemove = interaction.options.getUser('user');\n            \n            // Check if user has admin role\n            const adminRole = guild.roles.cache.get(config.adminRoleId);\n            if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n                return await interaction.reply({\n                    content: '‚ùå You do not have permission to remove users from tickets.',\n                    ephemeral: true\n                });\n            }\n            \n            // Check if this is a ticket channel\n            const ticket = await getTicket(channel.id);\n            if (!ticket) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            // Don't allow removing the ticket creator\n            if (userToRemove.id === ticket.user_id) {\n                return await interaction.reply({\n                    content: '‚ùå You cannot remove the ticket creator from their own ticket.',\n                    ephemeral: true\n                });\n            }\n            \n            // Remove user's permissions from ticket channel\n            await channel.permissionOverwrites.delete(userToRemove.id);\n            \n            await interaction.reply({\n                content: `‚úÖ ${userToRemove.toString()} has been removed from this ticket!`\n            });\n            \n            console.log(`User ${userToRemove.tag} removed from ticket ${ticket.id} by ${member.user.tag}`);\n            \n        } catch (error) {\n            console.error('Remove command error:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while removing the user from this ticket.',\n                ephemeral: true\n            });\n        }\n    }\n};\n\n// Rename ticket command\nconst renameCommand = {\n    data: new SlashCommandBuilder()\n        .setName('rename')\n        .setDescription('Rename this ticket channel')\n        .addStringOption(option =>\n            option.setName('name')\n                .setDescription('New name for the ticket')\n                .setRequired(true))\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            const guild = interaction.guild;\n            const member = interaction.member;\n            const channel = interaction.channel;\n            const newName = interaction.options.getString('name');\n            \n            // Check if user has admin role\n            const adminRole = guild.roles.cache.get(config.adminRoleId);\n            if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n                return await interaction.reply({\n                    content: '‚ùå You do not have permission to rename tickets.',\n                    ephemeral: true\n                });\n            }\n            \n            // Check if this is a ticket channel\n            const ticket = await getTicket(channel.id);\n            if (!ticket) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            // Clean the name for Discord channel naming rules\n            const cleanName = newName.toLowerCase().replace(/[^a-z0-9-]/g, '-').substring(0, 50);\n            \n            // Rename the channel\n            await channel.setName(cleanName);\n            \n            await interaction.reply({\n                content: `‚úÖ Ticket renamed to: **${cleanName}**`\n            });\n            \n            console.log(`Ticket ${ticket.id} renamed to ${cleanName} by ${member.user.tag}`);\n            \n        } catch (error) {\n            console.error('Rename command error:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while renaming the ticket.',\n                ephemeral: true\n            });\n        }\n    }\n};\n\n// Transfer ticket command\nconst transferCommand = {\n    data: new SlashCommandBuilder()\n        .setName('transfer')\n        .setDescription('Transfer this ticket to a different category')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            const guild = interaction.guild;\n            const member = interaction.member;\n            const channel = interaction.channel;\n            \n            // Check if user has admin role\n            const adminRole = guild.roles.cache.get(config.adminRoleId);\n            if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n                return await interaction.reply({\n                    content: '‚ùå You do not have permission to transfer tickets.',\n                    ephemeral: true\n                });\n            }\n            \n            // Check if this is a ticket channel\n            const ticket = await getTicket(channel.id);\n            if (!ticket) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            // Create select menu with all categories except current one\n            const options = Object.entries(TICKET_CATEGORIES)\n                .filter(([value, category]) => value !== ticket.category)\n                .map(([value, category]) => ({\n                    label: category.label,\n                    description: category.description,\n                    value: value,\n                    emoji: category.emoji\n                }));\n            \n            if (options.length === 0) {\n                return await interaction.reply({\n                    content: '‚ùå No other categories available to transfer to.',\n                    ephemeral: true\n                });\n            }\n            \n            const selectMenu = new StringSelectMenuBuilder()\n                .setCustomId('transfer_category')\n                .setPlaceholder('Select new category for this ticket...')\n                .addOptions(options);\n            \n            const row = new ActionRowBuilder()\n                .addComponents(selectMenu);\n            \n            const currentCategory = TICKET_CATEGORIES[ticket.category];\n            \n            await interaction.reply({\n                content: `üîÑ **Transfer Ticket**\\n\\nCurrent category: **${currentCategory ? currentCategory.label : 'Unknown'}**\\nSelect a new category from the menu below:`,\n                components: [row],\n                ephemeral: true\n            });\n            \n        } catch (error) {\n            console.error('Transfer command error:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while setting up the transfer.',\n                ephemeral: true\n            });\n        }\n    }\n};\n\n// Transfer admin command - notify specific admin about ticket\nconst transferAdminCommand = {\n    data: new SlashCommandBuilder()\n        .setName('transferadmin')\n        .setDescription('Notify a specific admin about this ticket via DM')\n        .addUserOption(option =>\n            option.setName('admin')\n                .setDescription('The admin to notify about this ticket')\n                .setRequired(true))\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            const guild = interaction.guild;\n            const member = interaction.member;\n            const channel = interaction.channel;\n            const targetAdmin = interaction.options.getUser('admin');\n            \n            // Check if user has admin role\n            const adminRole = guild.roles.cache.get(config.adminRoleId);\n            if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n                return await interaction.reply({\n                    content: '‚ùå You do not have permission to transfer tickets to admins.',\n                    ephemeral: true\n                });\n            }\n            \n            // Check if this is a ticket channel\n            const ticket = await getTicket(channel.id);\n            if (!ticket) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            // Get target admin as guild member\n            const targetMember = await guild.members.fetch(targetAdmin.id).catch(() => null);\n            if (!targetMember) {\n                return await interaction.reply({\n                    content: '‚ùå Could not find that user in this server.',\n                    ephemeral: true\n                });\n            }\n            \n            // Check if target user is an admin\n            if (!targetMember.roles.cache.has(adminRole.id)) {\n                return await interaction.reply({\n                    content: '‚ùå The specified user does not have admin permissions.',\n                    ephemeral: true\n                });\n            }\n            \n            // Get ticket details\n            const ticketCreator = await guild.members.fetch(ticket.user_id).catch(() => null);\n            const categoryInfo = TICKET_CATEGORIES[ticket.category];\n            const claimedBy = ticket.claimed_by ? await guild.members.fetch(ticket.claimed_by).catch(() => null) : null;\n            \n            // Send DM to target admin\n            try {\n                await targetAdmin.send({\n                    content: `üö® **Ticket Transfer Notification**\\n\\n` +\n                            `Hello ${targetAdmin.username}! You have been assigned to handle a support ticket.\\n\\n` +\n                            `**Ticket Information:**\\n` +\n                            `‚Ä¢ **Channel:** ${channel.toString()} - [Jump to Ticket](https://discord.com/channels/${guild.id}/${channel.id})\\n` +\n                            `‚Ä¢ **Ticket ID:** ${ticket.id}\\n` +\n                            `‚Ä¢ **Category:** ${categoryInfo ? categoryInfo.label : 'Unknown'} ${categoryInfo ? categoryInfo.emoji : ''}\\n` +\n                            `‚Ä¢ **Created by:** ${ticketCreator ? ticketCreator.user.tag : 'Unknown User'}\\n` +\n                            `‚Ä¢ **Currently claimed by:** ${claimedBy ? claimedBy.user.tag : 'Unclaimed'}\\n` +\n                            `‚Ä¢ **Transferred by:** ${member.user.tag}\\n` +\n                            `‚Ä¢ **Server:** ${guild.name}\\n` +\n                            `‚Ä¢ **Created:** ${new Date(ticket.created_at).toLocaleString()}\\n\\n` +\n                            `üîó **Direct Link:** https://discord.com/channels/${guild.id}/${channel.id}\\n\\n` +\n                            `Please click the link above or use the channel mention to access the ticket and provide assistance.`\n                });\n                \n                // Add the notified admin to the ticket channel\n                await channel.permissionOverwrites.edit(targetAdmin.id, {\n                    ViewChannel: true,\n                    SendMessages: true,\n                    ReadMessageHistory: true,\n                    ManageMessages: true\n                });\n                \n                await interaction.reply({\n                    content: `‚úÖ **Admin Notified Successfully**\\n\\n` +\n                            `${targetAdmin.toString()} has been:\\n` +\n                            `‚Ä¢ Sent a DM with ticket details and direct link\\n` +\n                            `‚Ä¢ Added to this ticket channel with full permissions\\n` +\n                            `‚Ä¢ Provided with all necessary information to assist`\n                });\n                \n                // Send notification in ticket\n                await channel.send({\n                    content: `üì¢ **Admin Transfer Notification**\\n\\n` +\n                            `${targetAdmin.toString()} has been notified about this ticket by ${member.toString()} and added to provide assistance.`\n                });\n                \n                console.log(`Ticket ${ticket.id} transferred to admin ${targetAdmin.tag} by ${member.user.tag}`);\n                \n            } catch (dmError) {\n                console.log(`Could not send DM to ${targetAdmin.tag}: ${dmError.message}`);\n                \n                // Still add them to the channel even if DM fails\n                await channel.permissionOverwrites.edit(targetAdmin.id, {\n                    ViewChannel: true,\n                    SendMessages: true,\n                    ReadMessageHistory: true,\n                    ManageMessages: true\n                });\n                \n                await interaction.reply({\n                    content: `‚ö†Ô∏è **Partial Success**\\n\\n` +\n                            `${targetAdmin.toString()} has been added to this ticket but could not receive a DM notification.\\n` +\n                            `**Reason:** ${dmError.message}\\n\\n` +\n                            `They now have access to this channel and can provide assistance.`\n                });\n                \n                // Notify in channel about the DM failure\n                await channel.send({\n                    content: `üì¢ **Admin Added to Ticket**\\n\\n` +\n                            `${targetAdmin.toString()} has been added to this ticket by ${member.toString()}. ` +\n                            `(DM notification failed - they may have DMs disabled)`\n                });\n            }\n            \n        } catch (error) {\n            console.error('Transfer admin command error:', error);\n            await interaction.reply({\n                content: '‚ùå An error occurred while transferring the ticket to the admin.',\n                ephemeral: true\n            });\n        }\n    }\n};\n\nclient.commands.set(setupCommand.data.name, setupCommand);\nclient.commands.set(addCommand.data.name, addCommand);\nclient.commands.set(removeCommand.data.name, removeCommand);\nclient.commands.set(renameCommand.data.name, renameCommand);\nclient.commands.set(transferCommand.data.name, transferCommand);\nclient.commands.set(transferAdminCommand.data.name, transferAdminCommand);\n\n// Ready event\nclient.once(Events.ClientReady, async (client) => {\n    console.log(`Ready! Logged in as ${client.user.tag}`);\n    \n    try {\n        // Get the specified guild and channels from config\n        const guild = client.guilds.cache.get(config.guildId);\n        if (!guild) {\n            console.error('Guild not found! Please check your guild ID in config');\n            return;\n        }\n        \n        const ticketChannel = guild.channels.cache.get(config.ticketChannelId);\n        if (!ticketChannel) {\n            console.error('Ticket channel not found! Please check your ticket channel ID in config');\n            return;\n        }\n        \n        // Clean up old messages and create new ticket panel\n        console.log('Setting up ticket panel...');\n        await createTicketPanel(ticketChannel, guild);\n        \n        // Reconnect to existing open tickets\n        console.log('Reconnecting to open tickets...');\n        await reconnectToTickets(client, guild);\n        \n        console.log('Bot initialization complete!');\n        \n    } catch (error) {\n        console.error('Error during bot initialization:', error);\n    }\n});\n\n// Feedback handling functions\nasync function handleFeedback(interaction) {\n    const [prefix, rating, ticketId] = interaction.customId.split('_');\n    \n    try {\n        if (prefix === 'feedback' && rating && rating !== 'text') {\n            // Star rating feedback\n            const ratingNum = parseInt(rating);\n            \n            // Save feedback to database\n            await saveFeedback(ticketId, interaction.user.id, ratingNum, null);\n            \n            // Send to feedback channel\n            const feedbackChannel = client.channels.cache.get(config.feedbackChannelId);\n            if (feedbackChannel) {\n                await feedbackChannel.send({\n                    embeds: [{\n                        title: '‚≠ê Star Rating Feedback',\n                        color: 0x00ff00,\n                        fields: [\n                            { name: 'üé´ Ticket ID', value: ticketId, inline: true },\n                            { name: 'üë§ User', value: interaction.user.tag, inline: true },\n                            { name: '‚≠ê Rating', value: `${ratingNum}/5 stars`, inline: true }\n                        ],\n                        timestamp: new Date(),\n                        footer: { text: 'PCRP Support Feedback System' }\n                    }]\n                });\n            }\n            \n            await interaction.reply({\n                content: `‚úÖ Thank you for your feedback! You rated our support **${ratingNum}/5 stars**.\\n\\nWe appreciate your time and will use this feedback to improve our service.`,\n                ephemeral: true\n            });\n            \n        } else if (prefix === 'feedback' && rating === 'text') {\n            // Text feedback - show modal\n            const modal = new ModalBuilder()\n                .setCustomId(`feedback_modal_${ticketId}`)\n                .setTitle('Share Your Feedback');\n                \n            const feedbackInput = new TextInputBuilder()\n                .setCustomId('feedback_comment')\n                .setLabel('How was your support experience?')\n                .setPlaceholder('Please share your thoughts about the support you received...')\n                .setStyle(TextInputStyle.Paragraph)\n                .setMinLength(10)\n                .setMaxLength(1000)\n                .setRequired(true);\n                \n            const firstActionRow = new ActionRowBuilder().addComponents(feedbackInput);\n            modal.addComponents(firstActionRow);\n            \n            await interaction.showModal(modal);\n        }\n    } catch (error) {\n        console.error('Feedback handling error:', error);\n        await interaction.reply({\n            content: '‚ùå There was an error processing your feedback. Please try again later.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function handleFeedbackModal(interaction) {\n    const ticketId = interaction.customId.replace('feedback_modal_', '');\n    const comment = interaction.fields.getTextInputValue('feedback_comment');\n    \n    try {\n        // Save feedback to database\n        await saveFeedback(ticketId, interaction.user.id, null, comment);\n        \n        // Send to feedback channel\n        const feedbackChannel = client.channels.cache.get(config.feedbackChannelId);\n        if (feedbackChannel) {\n            await feedbackChannel.send({\n                embeds: [{\n                    title: 'üìù Written Feedback',\n                    color: 0x0099ff,\n                    fields: [\n                        { name: 'üé´ Ticket ID', value: ticketId, inline: true },\n                        { name: 'üë§ User', value: interaction.user.tag, inline: true },\n                        { name: 'üí¨ Comment', value: comment.length > 1000 ? comment.substring(0, 997) + '...' : comment, inline: false }\n                    ],\n                    timestamp: new Date(),\n                    footer: { text: 'PCRP Support Feedback System' }\n                }]\n            });\n        }\n        \n        await interaction.reply({\n            content: `‚úÖ Thank you for your detailed feedback!\\n\\n**Your comment:**\\n> ${comment}\\n\\nWe appreciate your time and will use this feedback to improve our service.`,\n            ephemeral: true\n        });\n        \n    } catch (error) {\n        console.error('Feedback modal handling error:', error);\n        await interaction.reply({\n            content: '‚ùå There was an error saving your feedback. Please try again later.',\n            ephemeral: true\n        });\n    }\n}\n\n// Interaction event\nclient.on(Events.InteractionCreate, async (interaction) => {\n    try {\n        // Handle slash commands\n        if (interaction.isChatInputCommand()) {\n            const command = client.commands.get(interaction.commandName);\n            \n            if (!command) {\n                console.error(`No command matching ${interaction.commandName} was found.`);\n                return;\n            }\n            \n            await command.execute(interaction);\n        }\n        \n        // Handle select menu interactions\n        else if (interaction.isStringSelectMenu()) {\n            if (interaction.customId === 'ticket_category') {\n                await handleTicketCreation(interaction);\n            } else if (interaction.customId === 'transfer_category') {\n                await handleTicketTransfer(interaction);\n            }\n        }\n        \n        // Handle button interactions\n        else if (interaction.isButton()) {\n            if (interaction.customId === 'claim_ticket') {\n                await handleTicketClaim(interaction);\n            } else if (interaction.customId === 'close_ticket') {\n                await handleTicketClose(interaction);\n            } else if (interaction.customId.startsWith('feedback_')) {\n                await handleFeedback(interaction);\n            }\n        }\n        \n        // Handle modal submissions\n        else if (interaction.isModalSubmit()) {\n            if (interaction.customId.startsWith('feedback_modal_')) {\n                await handleFeedbackModal(interaction);\n            }\n        }\n    } catch (error) {\n        console.error('Interaction error:', error);\n        \n        const errorMessage = 'There was an error while executing this interaction!';\n        \n        if (interaction.replied || interaction.deferred) {\n            await interaction.followUp({ content: errorMessage, ephemeral: true });\n        } else {\n            await interaction.reply({ content: errorMessage, ephemeral: true });\n        }\n    }\n});\n\n// Initialize database\ninitializeDatabase().then(() => {\n    console.log('Database initialized successfully');\n}).catch(error => {\n    console.error('Failed to initialize database:', error);\n    process.exit(1);\n});\n\n// Error handling\nclient.on('error', error => {\n    console.error('Discord client error:', error);\n});\n\nprocess.on('unhandledRejection', error => {\n    console.error('Unhandled promise rejection:', error);\n});\n\nprocess.on('uncaughtException', error => {\n    console.error('Uncaught exception:', error);\n    process.exit(1);\n});\n\n// Login to Discord\nconst token = 'MTQwNzY1NzcwMTU0MjIwMzUwMw.GSjnC6.EhJi9azW78Zx3WsSR3YS4JLtSOT6QZlAfpeb2I';\n\nclient.login(token).catch(error => {\n    console.error('Failed to login to Discord:', error);\n    process.exit(1);\n});","size_bytes":63916},"replit.md":{"content":"# Overview\n\nThis is a Discord ticket system bot built with Discord.js v14 and SQLite. The bot provides a comprehensive support ticket management system where users can create tickets by selecting from predefined categories, and staff members can claim and manage these tickets. The system includes features like automatic ticket cleanup, transcript generation, user feedback collection system, and role-based permissions.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework\nThe bot is built on Discord.js v14 with a modular architecture using:\n- **Commands system**: Slash commands loaded dynamically from the `/commands` directory\n- **Events system**: Event handlers loaded from the `/events` directory for clean separation of concerns\n- **Gateway intents**: Configured for guilds, messages, message content, and members to handle ticket interactions\n\n## Database Layer\n- **SQLite database**: Local file-based storage using sqlite3 for persistent data\n- **Four main tables**:\n  - `tickets`: Stores ticket metadata (ID, channel, user, status, timestamps)\n  - `ticket_panels`: Tracks ticket creation panels in guilds\n  - `transcripts`: Stores ticket conversation history\n  - `feedback`: Stores user feedback with star ratings and comments\n- **Database initialization**: Automatic table creation on startup with proper schema\n\n## Ticket Management System\n- **Category-based tickets**: Seven predefined categories (General Support, Account Issues, Business, Membership, Staff Application, Report, Billing)\n- **Interactive UI**: Uses Discord select menus for ticket creation and buttons for ticket management\n- **Permission system**: Role-based access control using admin roles defined in config\n- **Automatic cleanup**: Configurable auto-deletion of closed tickets after specified time\n- **Transcript generation**: Conversation history saved before ticket deletion\n- **User feedback system**: Star ratings (1-5) and text comments collected when tickets close\n- **DM notifications**: Transcript delivery with interactive feedback collection buttons\n\n## Configuration Management\n- **JSON-based config**: Centralized configuration for guild IDs, channel IDs, role permissions, feedback channel\n- **Environment variables**: Bot token and sensitive data stored in .env file\n- **Flexible limits**: Configurable maximum tickets per user and auto-delete timers\n- **Channel routing**: Automatic feedback routing to designated feedback channel (ID: 1407668519990067200)\n\n## Event Handling Architecture\n- **Interaction router**: Single interaction handler that routes slash commands, select menus, button interactions, and modal submissions\n- **Ready event**: Bot initialization, ticket panel setup, and reconnection to existing tickets\n- **Feedback system**: Handles star ratings, text feedback modals, and automatic channel forwarding\n- **Error handling**: Comprehensive try-catch blocks with user-friendly error messages\n\n## Utility Modules\n- **Embed generator**: Standardized embed creation for consistent UI/UX\n- **Ticket manager**: Core business logic for ticket lifecycle management\n- **Database abstraction**: Clean separation between database operations and bot logic\n\n# External Dependencies\n\n## Core Dependencies\n- **discord.js**: Primary Discord API wrapper for bot functionality and interactions\n- **sqlite3**: Local database storage for persistent ticket data and configuration\n\n## Runtime Dependencies\n- **Node.js**: JavaScript runtime environment (requires v16.11.0+)\n- **dotenv**: Environment variable management for secure token storage\n\n## Discord Platform Integration\n- **Discord Gateway**: Real-time event handling for user interactions\n- **Discord Slash Commands**: Modern command interface with built-in validation\n- **Discord Permissions API**: Role-based access control and channel permissions\n- **Discord Channels API**: Dynamic channel creation and management for tickets","size_bytes":3952},"commands/setup.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\nconst { createTicketPanel } = require('../utils/ticketManager');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setup')\n        .setDescription('Setup the ticket system in this channel')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            await interaction.deferReply({ ephemeral: true });\n            \n            const success = await createTicketPanel(interaction.channel, interaction.guild);\n            \n            if (success) {\n                await interaction.editReply({\n                    content: '‚úÖ Ticket system has been successfully set up in this channel!'\n                });\n            } else {\n                await interaction.editReply({\n                    content: '‚ùå Failed to set up ticket system. Please try again.'\n                });\n            }\n        } catch (error) {\n            console.error('Setup command error:', error);\n            await interaction.editReply({\n                content: '‚ùå An error occurred while setting up the ticket system.'\n            });\n        }\n    }\n};\n","size_bytes":1217},"database/database.js":{"content":"const sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\n\nconst dbPath = path.join(__dirname, 'tickets.db');\nlet db = null;\n\nfunction initializeDatabase() {\n    return new Promise((resolve, reject) => {\n        db = new sqlite3.Database(dbPath, (err) => {\n            if (err) {\n                console.error('Error opening database:', err);\n                reject(err);\n                return;\n            }\n            \n            console.log('Connected to SQLite database');\n            \n            // Create tables if they don't exist\n            db.serialize(() => {\n                // Tickets table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS tickets (\n                        id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        user_id TEXT NOT NULL,\n                        category TEXT NOT NULL,\n                        claimed_by TEXT DEFAULT NULL,\n                        status TEXT DEFAULT 'open',\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                        closed_at DATETIME DEFAULT NULL\n                    )\n                `);\n                \n                // Ticket panels table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS ticket_panels (\n                        guild_id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        message_id TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n                \n                // Transcripts table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS transcripts (\n                        ticket_id TEXT PRIMARY KEY,\n                        content TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n            });\n            \n            resolve();\n        });\n    });\n}\n\nfunction getDatabase() {\n    return db;\n}\n\n// Ticket operations\nfunction createTicket(ticketId, channelId, userId, category) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT INTO tickets (id, channel_id, user_id, category)\n            VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([ticketId, channelId, userId, category], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM tickets WHERE channel_id = ? AND status = 'open'\n        `, [channelId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\nfunction getAllOpenTickets() {\n    return new Promise((resolve, reject) => {\n        db.all(`\n            SELECT * FROM tickets WHERE status = 'open'\n        `, [], (err, rows) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(rows);\n            }\n        });\n    });\n}\n\nfunction claimTicket(channelId, adminId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET claimed_by = ? WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([adminId, channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction closeTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET status = 'closed', closed_at = CURRENT_TIMESTAMP \n            WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\n// Panel operations\nfunction saveTicketPanel(guildId, channelId, messageId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO ticket_panels (guild_id, channel_id, message_id)\n            VALUES (?, ?, ?)\n        `);\n        \n        stmt.run([guildId, channelId, messageId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getTicketPanel(guildId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM ticket_panels WHERE guild_id = ?\n        `, [guildId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\n// Transcript operations\nfunction saveTranscript(ticketId, content) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO transcripts (ticket_id, content)\n            VALUES (?, ?)\n        `);\n        \n        stmt.run([ticketId, content], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nmodule.exports = {\n    initializeDatabase,\n    getDatabase,\n    createTicket,\n    getTicket,\n    getAllOpenTickets,\n    claimTicket,\n    closeTicket,\n    saveTicketPanel,\n    getTicketPanel,\n    saveTranscript\n};\n","size_bytes":5827},"events/interactionCreate.js":{"content":"const { Events, ChannelType, PermissionFlagsBits } = require('discord.js');\nconst { createTicket, handleTicketClaim, handleTicketClose } = require('../utils/ticketManager');\nconst config = require('../config.json');\n\nmodule.exports = {\n    name: Events.InteractionCreate,\n    async execute(interaction) {\n        try {\n            // Handle slash commands\n            if (interaction.isChatInputCommand()) {\n                const command = interaction.client.commands.get(interaction.commandName);\n                \n                if (!command) {\n                    console.error(`No command matching ${interaction.commandName} was found.`);\n                    return;\n                }\n                \n                await command.execute(interaction);\n            }\n            \n            // Handle select menu interactions\n            else if (interaction.isStringSelectMenu()) {\n                if (interaction.customId === 'ticket_category') {\n                    await handleTicketCreation(interaction);\n                }\n            }\n            \n            // Handle button interactions\n            else if (interaction.isButton()) {\n                if (interaction.customId === 'claim_ticket') {\n                    await handleTicketClaim(interaction);\n                } else if (interaction.customId === 'close_ticket') {\n                    await handleTicketClose(interaction);\n                }\n            }\n        } catch (error) {\n            console.error('Interaction error:', error);\n            \n            const errorMessage = 'There was an error while executing this interaction!';\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ content: errorMessage, ephemeral: true });\n            } else {\n                await interaction.reply({ content: errorMessage, ephemeral: true });\n            }\n        }\n    }\n};\n\nasync function handleTicketCreation(interaction) {\n    try {\n        const category = interaction.values[0];\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has an open ticket\n        const existingTickets = guild.channels.cache.filter(channel => \n            channel.name.startsWith('ticket-') && \n            channel.topic && \n            channel.topic.includes(user.id)\n        );\n        \n        if (existingTickets.size > 0) {\n            return await interaction.reply({\n                content: '‚ùå You already have an open ticket! Please close your existing ticket before creating a new one.',\n                ephemeral: true\n            });\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        const ticket = await createTicket(guild, user, category);\n        \n        if (ticket) {\n            await interaction.editReply({\n                content: `‚úÖ Your ticket has been created! Please check ${ticket.toString()}`\n            });\n        } else {\n            await interaction.editReply({\n                content: '‚ùå Failed to create ticket. Please try again or contact an administrator.'\n            });\n        }\n    } catch (error) {\n        console.error('Ticket creation error:', error);\n        await interaction.editReply({\n            content: '‚ùå An error occurred while creating your ticket.'\n        });\n    }\n}\n","size_bytes":3378},"events/ready.js":{"content":"const { Events } = require('discord.js');\nconst { createTicketPanel, reconnectToTickets } = require('../utils/ticketManager');\nconst config = require('../config.json');\n\nmodule.exports = {\n    name: Events.ClientReady,\n    once: true,\n    async execute(client) {\n        console.log(`Ready! Logged in as ${client.user.tag}`);\n        \n        try {\n            // Get the specified guild and channels from config\n            const guild = client.guilds.cache.get(config.guildId);\n            if (!guild) {\n                console.error('Guild not found! Please check your guild ID in config.json');\n                return;\n            }\n            \n            const ticketChannel = guild.channels.cache.get(config.ticketChannelId);\n            if (!ticketChannel) {\n                console.error('Ticket channel not found! Please check your ticket channel ID in config.json');\n                return;\n            }\n            \n            // Clean up old messages and create new ticket panel\n            console.log('Setting up ticket panel...');\n            await createTicketPanel(ticketChannel, guild);\n            \n            // Reconnect to existing open tickets\n            console.log('Reconnecting to open tickets...');\n            await reconnectToTickets(client, guild);\n            \n            console.log('Bot initialization complete!');\n            \n        } catch (error) {\n            console.error('Error during bot initialization:', error);\n        }\n    }\n};\n","size_bytes":1483},"utils/embeds.js":{"content":"const { EmbedBuilder } = require('discord.js');\n\nfunction createTicketPanelEmbed() {\n    return new EmbedBuilder()\n        .setTitle('Select Menus')\n        .setDescription('**Support Tickets**\\n\\nSelect the option that best fits your problem. A support ticket will be created for you automatically.')\n        .setColor(0x5865F2)\n        .setTimestamp();\n}\n\nfunction createTicketEmbed(user, categoryInfo) {\n    return new EmbedBuilder()\n        .setTitle(`üé´ New Ticket - ${categoryInfo.label}`)\n        .setDescription(\n            `Hello ${user.toString()}!\\n\\n` +\n            `Thank you for creating a ticket. Please describe your issue in detail and our support team will assist you shortly.\\n\\n` +\n            `**Category:** ${categoryInfo.label}\\n` +\n            `**Created:** <t:${Math.floor(Date.now() / 1000)}:F>`\n        )\n        .setColor(0x00FF00)\n        .setThumbnail(user.displayAvatarURL())\n        .setTimestamp();\n}\n\nfunction createTicketControlsEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üéõÔ∏è Ticket Controls')\n        .setDescription(\n            '**For Support Staff:**\\n' +\n            'üî∑ Click **Claim Ticket** to assign yourself to this ticket\\n' +\n            'üî∑ Click **Close Ticket** to close and archive this ticket\\n\\n' +\n            '**For Ticket Creator:**\\n' +\n            'üî∑ You can also close your own ticket using the **Close Ticket** button'\n        )\n        .setColor(0x0099FF)\n        .setTimestamp();\n}\n\nfunction createClaimedEmbed(admin) {\n    return new EmbedBuilder()\n        .setTitle('‚úÖ Ticket Claimed')\n        .setDescription(`This ticket has been claimed by ${admin.toString()}`)\n        .setColor(0xFFFF00)\n        .setTimestamp();\n}\n\nfunction createClosedEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üîí Ticket Closed')\n        .setDescription('This ticket has been closed and will be deleted shortly.')\n        .setColor(0xFF0000)\n        .setTimestamp();\n}\n\nmodule.exports = {\n    createTicketPanelEmbed,\n    createTicketEmbed,\n    createTicketControlsEmbed,\n    createClaimedEmbed,\n    createClosedEmbed\n};\n","size_bytes":2108},"utils/ticketManager.js":{"content":"const { ChannelType, PermissionFlagsBits, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst { createTicket: dbCreateTicket, getTicket, claimTicket, closeTicket, saveTicketPanel, getAllOpenTickets, saveTranscript } = require('../database/database');\nconst { createTicketEmbed, createTicketControlsEmbed, createTicketPanelEmbed } = require('./embeds');\nconst config = require('../config.json');\n\n// Ticket categories mapping\nconst TICKET_CATEGORIES = {\n    'general_query': {\n        label: 'General Support',\n        description: 'General questions and support',\n        emoji: 'üîß'\n    },\n    'account_issues': {\n        label: 'Account Issues',\n        description: 'Problems with your account',\n        emoji: 'üìß'\n    },\n    'business_ticket': {\n        label: 'Business Ticket',\n        description: 'Business-related inquiries',\n        emoji: 'üíº'\n    },\n    'membership_ticket': {\n        label: 'Membership Ticket',\n        description: 'Membership support and questions',\n        emoji: 'üëë'\n    },\n    'staff_application': {\n        label: 'Staff Application',\n        description: 'Apply to join our staff team',\n        emoji: 'üìù'\n    },\n    'report': {\n        label: 'Report',\n        description: 'Report users or issues',\n        emoji: '‚ö†Ô∏è'\n    },\n    'billing': {\n        label: 'Billing Support',\n        description: 'Payment and billing issues',\n        emoji: 'üí≥'\n    }\n};\n\nasync function createTicketPanel(channel, guild) {\n    try {\n        // Clear existing messages in the channel\n        const messages = await channel.messages.fetch({ limit: 100 });\n        if (messages.size > 0) {\n            await channel.bulkDelete(messages).catch(console.error);\n        }\n        \n        // Create select menu options\n        const options = Object.entries(TICKET_CATEGORIES).map(([value, category]) => ({\n            label: category.label,\n            description: category.description,\n            value: value,\n            emoji: category.emoji\n        }));\n        \n        const selectMenu = new StringSelectMenuBuilder()\n            .setCustomId('ticket_category')\n            .setPlaceholder('Select the option that best fits your problem...')\n            .addOptions(options);\n        \n        const row = new ActionRowBuilder()\n            .addComponents(selectMenu);\n        \n        const embed = createTicketPanelEmbed();\n        \n        const message = await channel.send({\n            embeds: [embed],\n            components: [row]\n        });\n        \n        // Save panel info to database\n        await saveTicketPanel(guild.id, channel.id, message.id);\n        \n        console.log('Ticket panel created successfully');\n        return true;\n    } catch (error) {\n        console.error('Error creating ticket panel:', error);\n        return false;\n    }\n}\n\nasync function createTicket(guild, user, category) {\n    try {\n        const categoryInfo = TICKET_CATEGORIES[category];\n        if (!categoryInfo) {\n            throw new Error('Invalid ticket category');\n        }\n        \n        // Generate unique ticket ID\n        const ticketId = `ticket-${user.username}-${Date.now()}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        // Get admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        \n        // Create ticket channel\n        const ticketChannel = await guild.channels.create({\n            name: ticketId,\n            type: ChannelType.GuildText,\n            topic: `Ticket for ${user.tag} (${user.id}) - Category: ${categoryInfo.label}`,\n            permissionOverwrites: [\n                {\n                    id: guild.roles.everyone,\n                    deny: [PermissionFlagsBits.ViewChannel]\n                },\n                {\n                    id: user.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.SendMessages,\n                        PermissionFlagsBits.ReadMessageHistory\n                    ]\n                },\n                ...(adminRole ? [{\n                    id: adminRole.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.SendMessages,\n                        PermissionFlagsBits.ReadMessageHistory,\n                        PermissionFlagsBits.ManageMessages\n                    ]\n                }] : [])\n            ]\n        });\n        \n        // Create ticket controls\n        const claimButton = new ButtonBuilder()\n            .setCustomId('claim_ticket')\n            .setLabel('Claim Ticket')\n            .setStyle(ButtonStyle.Primary)\n            .setEmoji('üëã');\n        \n        const closeButton = new ButtonBuilder()\n            .setCustomId('close_ticket')\n            .setLabel('Close Ticket')\n            .setStyle(ButtonStyle.Danger)\n            .setEmoji('üîí');\n        \n        const controlRow = new ActionRowBuilder()\n            .addComponents(claimButton, closeButton);\n        \n        // Send ticket message\n        const ticketEmbed = createTicketEmbed(user, categoryInfo);\n        const controlsEmbed = createTicketControlsEmbed();\n        \n        await ticketChannel.send({\n            content: `${user.toString()}${adminRole ? ` ${adminRole.toString()}` : ''}`,\n            embeds: [ticketEmbed, controlsEmbed],\n            components: [controlRow]\n        });\n        \n        // Save ticket to database\n        await dbCreateTicket(ticketId, ticketChannel.id, user.id, category);\n        \n        console.log(`Ticket created: ${ticketId} for user ${user.tag}`);\n        return ticketChannel;\n    } catch (error) {\n        console.error('Error creating ticket:', error);\n        return null;\n    }\n}\n\nasync function handleTicketClaim(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to claim tickets.',\n                ephemeral: true\n            });\n        }\n        \n        // Get ticket from database\n        const ticket = await getTicket(channel.id);\n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        if (ticket.claimed_by) {\n            const claimedUser = await guild.members.fetch(ticket.claimed_by).catch(() => null);\n            return await interaction.reply({\n                content: `‚ùå This ticket is already claimed by ${claimedUser ? claimedUser.toString() : 'another admin'}.`,\n                ephemeral: true\n            });\n        }\n        \n        // Claim the ticket\n        await claimTicket(channel.id, member.id);\n        \n        await interaction.reply({\n            content: `‚úÖ ${member.toString()} has claimed this ticket!`\n        });\n        \n        console.log(`Ticket ${ticket.id} claimed by ${member.user.tag}`);\n    } catch (error) {\n        console.error('Error claiming ticket:', error);\n        await interaction.reply({\n            content: '‚ùå An error occurred while claiming the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function handleTicketClose(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role or is the ticket creator\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        const ticket = await getTicket(channel.id);\n        \n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        const isAdmin = adminRole && member.roles.cache.has(adminRole.id);\n        const isTicketCreator = ticket.user_id === member.id;\n        \n        if (!isAdmin && !isTicketCreator) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to close this ticket.',\n                ephemeral: true\n            });\n        }\n        \n        await interaction.reply({\n            content: 'üîí Closing ticket and saving transcript...'\n        });\n        \n        // Generate transcript\n        const messages = await channel.messages.fetch({ limit: 100 });\n        const transcript = messages.reverse().map(msg => \n            `[${msg.createdAt.toISOString()}] ${msg.author.tag}: ${msg.content}`\n        ).join('\\n');\n        \n        // Save transcript\n        await saveTranscript(ticket.id, transcript);\n        \n        // Close ticket in database\n        await closeTicket(channel.id);\n        \n        // Send transcript to logs channel if configured\n        const logsChannel = guild.channels.cache.get(config.logsChannelId);\n        if (logsChannel) {\n            const user = await guild.members.fetch(ticket.user_id).catch(() => null);\n            const claimedBy = ticket.claimed_by ? await guild.members.fetch(ticket.claimed_by).catch(() => null) : null;\n            \n            await logsChannel.send({\n                content: `**Ticket Closed**\\n` +\n                        `**Ticket ID:** ${ticket.id}\\n` +\n                        `**Created by:** ${user ? user.toString() : 'Unknown User'}\\n` +\n                        `**Claimed by:** ${claimedBy ? claimedBy.toString() : 'Unclaimed'}\\n` +\n                        `**Closed by:** ${member.toString()}\\n` +\n                        `**Category:** ${ticket.category}\\n` +\n                        `**Created:** ${ticket.created_at}\\n` +\n                        `**Closed:** ${new Date().toISOString()}`\n            });\n        }\n        \n        // Delete channel after a short delay\n        setTimeout(async () => {\n            try {\n                await channel.delete();\n                console.log(`Ticket channel ${channel.name} deleted`);\n            } catch (error) {\n                console.error('Error deleting ticket channel:', error);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('Error closing ticket:', error);\n        await interaction.followUp({\n            content: '‚ùå An error occurred while closing the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function reconnectToTickets(client, guild) {\n    try {\n        const openTickets = await getAllOpenTickets();\n        let reconnectedCount = 0;\n        \n        for (const ticket of openTickets) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channel_id);\n                if (!channel) {\n                    // Channel doesn't exist, mark ticket as closed\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed orphaned ticket: ${ticket.id}`);\n                    continue;\n                }\n                \n                // Verify channel is still a valid ticket\n                if (!channel.name.startsWith('ticket-')) {\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed invalid ticket channel: ${ticket.id}`);\n                    continue;\n                }\n                \n                reconnectedCount++;\n                console.log(`Reconnected to ticket: ${ticket.id} in channel ${channel.name}`);\n            } catch (error) {\n                console.error(`Error reconnecting to ticket ${ticket.id}:`, error);\n                // Mark as closed if there's an error\n                await closeTicket(ticket.channel_id);\n            }\n        }\n        \n        console.log(`Reconnected to ${reconnectedCount} open tickets`);\n    } catch (error) {\n        console.error('Error during ticket reconnection:', error);\n    }\n}\n\nmodule.exports = {\n    createTicketPanel,\n    createTicket,\n    handleTicketClaim,\n    handleTicketClose,\n    reconnectToTickets,\n    TICKET_CATEGORIES\n};\n","size_bytes":12297}}}