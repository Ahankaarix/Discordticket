{"file_contents":{"index.js":{"content":"const { Client, GatewayIntentBits, Collection, SlashCommandBuilder, PermissionFlagsBits, EmbedBuilder, ChannelType, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle, Events, AttachmentBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js');\nconst sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\nconst fs = require('fs');\n// Bot Token - Replace with your actual Discord bot token\nconst DISCORD_TOKEN = \"YOUR_DISCORD_BOT_TOKEN_HERE\";\n\n// Configuration\nconst config = {\n    guildId: \"1407656756779155477\",\n    ticketChannelId: \"1407656785564930068\",\n    logsChannelId: \"1407656810453663754\",\n    adminRoleId: \"1407657166114127962\",\n    feedbackChannelId: \"1407668519990067200\",\n    ticketCategoryId: null,\n    maxTicketsPerUser: 1,\n    autoDeleteAfterClose: 5000,\n    transcriptChannelId: null\n};\n\n// Database setup\nconst dbPath = path.join(__dirname, 'tickets.db');\nlet db = null;\n\nfunction initializeDatabase() {\n    return new Promise((resolve, reject) => {\n        db = new sqlite3.Database(dbPath, (err) => {\n            if (err) {\n                console.error('Error opening database:', err);\n                reject(err);\n                return;\n            }\n            \n            console.log('Connected to SQLite database');\n            \n            // Create tables if they don't exist\n            db.serialize(() => {\n                // Tickets table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS tickets (\n                        id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        user_id TEXT NOT NULL,\n                        category TEXT NOT NULL,\n                        claimed_by TEXT DEFAULT NULL,\n                        status TEXT DEFAULT 'open',\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                        closed_at DATETIME DEFAULT NULL\n                    )\n                `);\n                \n                // Ticket panels table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS ticket_panels (\n                        guild_id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        message_id TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n                \n                // Transcripts table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS transcripts (\n                        ticket_id TEXT PRIMARY KEY,\n                        content TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n                \n                // Feedback table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS feedback (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        ticket_id TEXT NOT NULL,\n                        user_id TEXT NOT NULL,\n                        rating INTEGER,\n                        comment TEXT,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n            });\n            \n            resolve();\n        });\n    });\n}\n\n// Database functions\nfunction createTicketDB(ticketId, channelId, userId, category) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT INTO tickets (id, channel_id, user_id, category)\n            VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([ticketId, channelId, userId, category], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM tickets WHERE channel_id = ? AND status = 'open'\n        `, [channelId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\nfunction getAnyTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM tickets WHERE channel_id = ?\n        `, [channelId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\nfunction getTicketById(ticketId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM tickets WHERE id = ?\n        `, [ticketId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\nfunction reopenTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET status = 'open', closed_at = NULL \n            WHERE channel_id = ?\n        `);\n        \n        stmt.run([channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getAllOpenTickets() {\n    return new Promise((resolve, reject) => {\n        db.all(`\n            SELECT * FROM tickets WHERE status = 'open'\n        `, [], (err, rows) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(rows);\n            }\n        });\n    });\n}\n\nfunction claimTicket(channelId, adminId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET claimed_by = ? WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([adminId, channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction closeTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET status = 'closed', closed_at = CURRENT_TIMESTAMP \n            WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction saveTicketPanel(guildId, channelId, messageId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO ticket_panels (guild_id, channel_id, message_id)\n            VALUES (?, ?, ?)\n        `);\n        \n        stmt.run([guildId, channelId, messageId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction saveTranscript(ticketId, content) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO transcripts (ticket_id, content)\n            VALUES (?, ?)\n        `);\n        \n        stmt.run([ticketId, content], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction updateTicketCategory(channelId, newCategory) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET category = ? WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([newCategory, channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction saveFeedback(ticketId, userId, rating, comment) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT INTO feedback (ticket_id, user_id, rating, comment)\n            VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([ticketId, userId, rating, comment], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\n// Ticket categories\nconst TICKET_CATEGORIES = {\n    'general_query': {\n        label: 'General Support',\n        description: 'General questions and support',\n        emoji: 'üîß'\n    },\n    'account_issues': {\n        label: 'Account Issues',\n        description: 'Problems with your account',\n        emoji: 'üìß'\n    },\n    'business_ticket': {\n        label: 'Business Ticket',\n        description: 'Business-related inquiries',\n        emoji: 'üíº'\n    },\n    'membership_ticket': {\n        label: 'Membership Ticket',\n        description: 'Membership support and questions',\n        emoji: 'üëë'\n    },\n    'staff_application': {\n        label: 'Staff Application',\n        description: 'Apply to join our staff team',\n        emoji: 'üìù'\n    },\n    'report': {\n        label: 'Report',\n        description: 'Report users or issues',\n        emoji: '‚ö†Ô∏è'\n    },\n    'billing': {\n        label: 'Billing Support',\n        description: 'Payment and billing issues',\n        emoji: 'üí≥'\n    }\n};\n\n// HTML Transcript Generator\nfunction generateHTMLTranscript(ticket, messages, guild, closedBy) {\n    const categoryInfo = TICKET_CATEGORIES[ticket.category];\n    const categoryLabel = categoryInfo ? categoryInfo.label : 'Unknown';\n    \n    const messagesHTML = messages.map(msg => {\n        const timestamp = msg.createdAt.toLocaleString();\n        const author = msg.author.tag;\n        const avatar = msg.author.displayAvatarURL();\n        const content = msg.content || '[No text content]';\n        const isBot = msg.author.bot ? 'bot-message' : 'user-message';\n        \n        return `\n        <div class=\"message ${isBot}\">\n            <img src=\"${avatar}\" alt=\"${author}\" class=\"avatar\">\n            <div class=\"message-content\">\n                <div class=\"message-header\">\n                    <span class=\"author\">${author}</span>\n                    <span class=\"timestamp\">${timestamp}</span>\n                </div>\n                <div class=\"message-text\">${content}</div>\n            </div>\n        </div>`;\n    }).join('\\\\n');\n\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Ticket Transcript - ${ticket.id}</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: #36393f;\n            color: #dcddde;\n            line-height: 1.6;\n        }\n        \n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        \n        .header {\n            background: #2f3136;\n            padding: 20px;\n            border-radius: 8px;\n            margin-bottom: 20px;\n            border-left: 4px solid #5865f2;\n        }\n        \n        .header h1 {\n            color: #5865f2;\n            margin-bottom: 10px;\n        }\n        \n        .info-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 15px;\n            margin-top: 15px;\n        }\n        \n        .info-item {\n            background: #40444b;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        \n        .info-label {\n            color: #b9bbbe;\n            font-size: 12px;\n            text-transform: uppercase;\n            margin-bottom: 5px;\n        }\n        \n        .info-value {\n            color: #ffffff;\n            font-weight: 500;\n        }\n        \n        .messages {\n            background: #2f3136;\n            border-radius: 8px;\n            padding: 20px;\n        }\n        \n        .message {\n            display: flex;\n            margin-bottom: 15px;\n            padding: 10px;\n            border-radius: 4px;\n        }\n        \n        .user-message {\n            background: #40444b;\n        }\n        \n        .bot-message {\n            background: #36393f;\n            border-left: 3px solid #5865f2;\n        }\n        \n        .avatar {\n            width: 40px;\n            height: 40px;\n            border-radius: 50%;\n            margin-right: 15px;\n        }\n        \n        .message-content {\n            flex: 1;\n        }\n        \n        .message-header {\n            display: flex;\n            align-items: center;\n            margin-bottom: 5px;\n        }\n        \n        .author {\n            font-weight: 600;\n            color: #ffffff;\n            margin-right: 10px;\n        }\n        \n        .timestamp {\n            font-size: 12px;\n            color: #72767d;\n        }\n        \n        .message-text {\n            color: #dcddde;\n            word-wrap: break-word;\n        }\n        \n        .footer {\n            text-align: center;\n            margin-top: 30px;\n            padding: 20px;\n            background: #2f3136;\n            border-radius: 8px;\n            color: #72767d;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>üé´ Ticket Transcript</h1>\n            <div class=\"info-grid\">\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Ticket ID</div>\n                    <div class=\"info-value\">${ticket.id}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Category</div>\n                    <div class=\"info-value\">${categoryLabel}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Created</div>\n                    <div class=\"info-value\">${new Date(ticket.created_at).toLocaleString()}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Closed</div>\n                    <div class=\"info-value\">${new Date().toLocaleString()}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Closed By</div>\n                    <div class=\"info-value\">${closedBy.user.tag}</div>\n                </div>\n                <div class=\"info-item\">\n                    <div class=\"info-label\">Server</div>\n                    <div class=\"info-value\">${guild.name}</div>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"messages\">\n            <h2 style=\"margin-bottom: 20px; color: #ffffff;\">üí¨ Conversation</h2>\n            ${messagesHTML}\n        </div>\n        \n        <div class=\"footer\">\n            <p>Generated on ${new Date().toLocaleString()}</p>\n            <p>PCRP Ticket System - Discord Bot</p>\n        </div>\n    </div>\n</body>\n</html>`;\n}\n\n// Embed functions\nfunction createTicketPanelEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üéüÔ∏è Support Tickets')\n        .setDescription(\n            'Please choose the option that best matches your issue from the menu below.\\n' +\n            'Once you select, ‚úÖ a private ticket channel will be created where our team can assist you.\\n\\n' +\n            '‚ú® **How it works:**\\n' +\n            '‚Ä¢ Pick a category from the menu ‚¨áÔ∏è\\n' +\n            '‚Ä¢ A new ticket will open üìÇ\\n' +\n            '‚Ä¢ Our staff will reply as soon as possible ‚è≥'\n        )\n        .setColor(0x5865F2)\n        .setTimestamp();\n}\n\nfunction createTicketEmbed(user, categoryInfo) {\n    return new EmbedBuilder()\n        .setTitle(`üé´ New Ticket - ${categoryInfo.label}`)\n        .setDescription(\n            `Hello ${user.toString()}!\\n\\n` +\n            `Thank you for creating a ticket. Please describe your issue in detail and our support team will assist you shortly.\\n\\n` +\n            `**Category:** ${categoryInfo.label}\\n` +\n            `**Created:** <t:${Math.floor(Date.now() / 1000)}:F>`\n        )\n        .setColor(0x00FF00)\n        .setThumbnail(user.displayAvatarURL())\n        .setTimestamp();\n}\n\nfunction createTicketControlsEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üîß Staff Management Panel')\n        .setDescription(\n            '**For Support Staff:**\\n' +\n            'üî∑ Click **Claim Ticket** to assign yourself to this ticket\\n' +\n            'üî∑ Click **Close Ticket** to close and archive this ticket\\n\\n' +\n            '**For User:**\\n' +\n            'üî∑ You can also close your ticket using the **Close Ticket** button'\n        )\n        .setColor(0x0099FF)\n        .setTimestamp();\n}\n\n// Ticket management functions\nasync function createTicketPanel(channel, guild) {\n    try {\n        // Clear existing messages in the channel\n        const messages = await channel.messages.fetch({ limit: 100 });\n        if (messages.size > 0) {\n            await channel.bulkDelete(messages).catch(console.error);\n        }\n        \n        // Create select menu options\n        const options = Object.entries(TICKET_CATEGORIES).map(([value, category]) => ({\n            label: category.label,\n            description: category.description,\n            value: value,\n            emoji: category.emoji\n        }));\n        \n        const selectMenu = new StringSelectMenuBuilder()\n            .setCustomId('ticket_category')\n            .setPlaceholder('Select the option that best fits your problem...')\n            .addOptions(options);\n        \n        const row = new ActionRowBuilder()\n            .addComponents(selectMenu);\n        \n        const embed = createTicketPanelEmbed();\n        \n        const message = await channel.send({\n            embeds: [embed],\n            components: [row]\n        });\n        \n        // Save panel info to database\n        await saveTicketPanel(guild.id, channel.id, message.id);\n        \n        console.log('Ticket panel created successfully');\n        return true;\n    } catch (error) {\n        console.error('Error creating ticket panel:', error);\n        return false;\n    }\n}\n\nasync function createTicket(guild, user, category) {\n    try {\n        const categoryInfo = TICKET_CATEGORIES[category];\n        if (!categoryInfo) {\n            throw new Error('Invalid ticket category');\n        }\n        \n        // Generate unique ticket ID with category\n        const categoryShortName = {\n            'general_query': 'general',\n            'account_issues': 'account',\n            'business_ticket': 'business',\n            'membership_ticket': 'membership',\n            'staff_application': 'staff',\n            'report': 'report',\n            'billing': 'billing'\n        }[category] || 'general';\n        \n        // Generate a simple counter-based ticket ID\n        const existingTickets = await new Promise((resolve, reject) => {\n            db.all(\"SELECT COUNT(*) as count FROM tickets WHERE user_id = ?\", [user.id], (err, rows) => {\n                if (err) reject(err);\n                else resolve(rows[0].count);\n            });\n        });\n        const ticketNumber = (existingTickets + 1).toString().padStart(3, '0');\n        const ticketId = `pcrp-${user.username}-${categoryShortName}-${ticketNumber}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        // Get admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        \n        // Create ticket channel with restricted permissions\n        const ticketChannel = await guild.channels.create({\n            name: ticketId,\n            type: ChannelType.GuildText,\n            topic: `Ticket for ${user.tag} (${user.id}) - Category: ${categoryInfo.label}`,\n            permissionOverwrites: [\n                {\n                    id: guild.roles.everyone,\n                    deny: [PermissionFlagsBits.ViewChannel]\n                },\n                {\n                    id: user.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.SendMessages,\n                        PermissionFlagsBits.ReadMessageHistory\n                    ]\n                },\n                ...(adminRole ? [{\n                    id: adminRole.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.ReadMessageHistory,\n                        PermissionFlagsBits.ManageMessages\n                    ],\n                    deny: [PermissionFlagsBits.SendMessages]\n                }] : [])\n            ]\n        });\n        \n        // Create ticket controls\n        const claimButton = new ButtonBuilder()\n            .setCustomId('claim_ticket')\n            .setLabel('Claim Ticket')\n            .setStyle(ButtonStyle.Primary)\n            .setEmoji('üëã');\n        \n        const closeButton = new ButtonBuilder()\n            .setCustomId('close_ticket')\n            .setLabel('Close Ticket')\n            .setStyle(ButtonStyle.Danger)\n            .setEmoji('üîí');\n        \n        const controlRow = new ActionRowBuilder()\n            .addComponents(claimButton, closeButton);\n        \n        // Send ticket message\n        const ticketEmbed = createTicketEmbed(user, categoryInfo);\n        \n        // Send main ticket message for everyone\n        await ticketChannel.send({\n            content: `${user.toString()}${adminRole ? ` ${adminRole.toString()}` : ''}`,\n            embeds: [ticketEmbed]\n        });\n        \n        // Send auto-response message based on category\n        await sendAutoResponse(ticketChannel, user, category);\n        \n        // Send controls message only visible to admins\n        if (adminRole) {\n            const controlsEmbed = createTicketControlsEmbed();\n            await ticketChannel.send({\n                content: `${adminRole.toString()}`,\n                embeds: [controlsEmbed],\n                components: [controlRow]\n            });\n        }\n        \n        // Save ticket to database\n        await createTicketDB(ticketId, ticketChannel.id, user.id, category);\n        \n        console.log(`Ticket created: ${ticketId} for user ${user.tag}`);\n        return ticketChannel;\n    } catch (error) {\n        console.error('Error creating ticket:', error);\n        return null;\n    }\n}\n\nasync function handleTicketClaim(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to claim tickets.',\n                ephemeral: true\n            });\n        }\n        \n        // Get ticket from database\n        let ticket = await getTicket(channel.id);\n        if (!ticket) {\n            // Try auto-reconnect first\n            const reconnected = await autoReconnectOnError(client, channel.id);\n            \n            if (reconnected) {\n                // Try to get ticket again after reconnection\n                ticket = await getTicket(channel.id).catch(() => null);\n                if (ticket) {\n                    console.log(`‚úÖ Auto-reconnect successful for ticket claim in ${channel.name}`);\n                } else {\n                    return await interaction.reply({\n                        content: '‚ùå This is not a valid ticket channel.',\n                        ephemeral: true\n                    });\n                }\n            } else {\n                return await interaction.reply({\n                    content: '‚ùå This is not a valid ticket channel.',\n                    ephemeral: true\n                });\n            }\n        }\n        \n        if (ticket.claimed_by) {\n            const claimedUser = await guild.members.fetch(ticket.claimed_by).catch(() => null);\n            return await interaction.reply({\n                content: `‚ùå This ticket is already claimed by ${claimedUser ? claimedUser.toString() : 'another admin'}.`,\n                ephemeral: true\n            });\n        }\n        \n        // Claim the ticket\n        await claimTicket(channel.id, member.id);\n        \n        // Give claimer permission to send messages\n        await channel.permissionOverwrites.edit(member.id, {\n            ViewChannel: true,\n            SendMessages: true,\n            ReadMessageHistory: true,\n            ManageMessages: true\n        });\n        \n        await interaction.reply({\n            content: `‚úÖ ${member.toString()} has claimed this ticket!`\n        });\n        \n        console.log(`Ticket ${ticket.id} claimed by ${member.user.tag}`);\n    } catch (error) {\n        console.error('Error claiming ticket:', error);\n        if (!interaction.replied && !interaction.deferred) {\n            await interaction.reply({\n                content: '‚ùå An error occurred while claiming the ticket.',\n                ephemeral: true\n            });\n        }\n    }\n}\n\nasync function handleTicketClose(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role or is the ticket creator\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        let ticket = await getTicket(channel.id);\n        \n        if (!ticket) {\n            // Try auto-reconnect first\n            const reconnected = await autoReconnectOnError(client, channel.id);\n            \n            if (reconnected) {\n                // Try to get ticket again after reconnection\n                ticket = await getTicket(channel.id).catch(() => null);\n                if (ticket) {\n                    console.log(`‚úÖ Auto-reconnect successful for ticket close in ${channel.name}`);\n                } else {\n                    if (!interaction.replied && !interaction.deferred) {\n                        return await interaction.reply({\n                            content: '‚ùå This is not a valid ticket channel.',\n                            ephemeral: true\n                        });\n                    }\n                    return;\n                }\n            } else {\n                if (!interaction.replied && !interaction.deferred) {\n                    return await interaction.reply({\n                        content: '‚ùå This is not a valid ticket channel.',\n                        ephemeral: true\n                    });\n                }\n                return;\n            }\n        }\n        \n        const isAdmin = adminRole && member.roles.cache.has(adminRole.id);\n        const isTicketCreator = ticket.user_id === member.id;\n        \n        if (!isAdmin && !isTicketCreator) {\n            if (!interaction.replied && !interaction.deferred) {\n                return await interaction.reply({\n                    content: '‚ùå You do not have permission to close this ticket.',\n                    ephemeral: true\n                });\n            }\n            return;\n        }\n        \n        // Defer the interaction to give us more time for processing\n        if (!interaction.replied && !interaction.deferred) {\n            await interaction.deferReply();\n        }\n        \n        // Generate transcript\n        const messages = await channel.messages.fetch({ limit: 100 });\n        const sortedMessages = messages.reverse();\n        \n        // Generate plain text transcript\n        const transcript = sortedMessages.map(msg => \n            `[${msg.createdAt.toISOString()}] ${msg.author.tag}: ${msg.content}`\n        ).join('\\n');\n        \n        // Generate HTML transcript\n        const htmlTranscript = generateHTMLTranscript(ticket, sortedMessages, guild, member);\n        const fileName = `transcript-${ticket.id}.html`;\n        const filePath = path.join(__dirname, fileName);\n        \n        // Save HTML file\n        fs.writeFileSync(filePath, htmlTranscript);\n        \n        // Save transcript to database\n        await saveTranscript(ticket.id, transcript);\n        \n        // Close ticket in database\n        await closeTicket(channel.id);\n        \n        // Update the user about the process\n        if (interaction.deferred) {\n            await interaction.editReply({\n                content: '‚úÖ Ticket closed successfully! Transcript saved and sent to logs.'\n            });\n        }\n        \n        // Get ticket creator for DM and logs\n        const user = await guild.members.fetch(ticket.user_id).catch(() => null);\n        const claimedBy = ticket.claimed_by ? await guild.members.fetch(ticket.claimed_by).catch(() => null) : null;\n        \n        // Create attachment for HTML transcript\n        const attachment = new AttachmentBuilder(filePath, { name: fileName });\n        \n        // Send transcript to logs channel if configured\n        const logsChannel = guild.channels.cache.get(config.logsChannelId);\n        if (logsChannel) {\n            await logsChannel.send({\n                content: `**Ticket Closed**\\n` +\n                        `**Ticket ID:** ${ticket.id}\\n` +\n                        `**Created by:** ${user ? user.toString() : 'Unknown User'}\\n` +\n                        `**Claimed by:** ${claimedBy ? claimedBy.toString() : 'Unclaimed'}\\n` +\n                        `**Closed by:** ${member.toString()}\\n` +\n                        `**Category:** ${ticket.category}\\n` +\n                        `**Created:** ${ticket.created_at}\\n` +\n                        `**Closed:** ${new Date().toISOString()}`,\n                files: [attachment]\n            });\n        }\n        \n        // Send transcript copy to ticket creator via DM\n        if (user) {\n            try {\n                const categoryInfo = TICKET_CATEGORIES[ticket.category];\n                const userAttachment = new AttachmentBuilder(filePath, { name: fileName });\n                \n                // Create feedback buttons\n                const star1 = new ButtonBuilder()\n                    .setCustomId(`feedback_1_${ticket.id}`)\n                    .setLabel('1‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star2 = new ButtonBuilder()\n                    .setCustomId(`feedback_2_${ticket.id}`)\n                    .setLabel('2‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star3 = new ButtonBuilder()\n                    .setCustomId(`feedback_3_${ticket.id}`)\n                    .setLabel('3‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star4 = new ButtonBuilder()\n                    .setCustomId(`feedback_4_${ticket.id}`)\n                    .setLabel('4‚≠ê')\n                    .setStyle(ButtonStyle.Secondary);\n                \n                const star5 = new ButtonBuilder()\n                    .setCustomId(`feedback_5_${ticket.id}`)\n                    .setLabel('5‚≠ê')\n                    .setStyle(ButtonStyle.Success);\n                \n                const feedbackRow = new ActionRowBuilder()\n                    .addComponents(star1, star2, star3, star4, star5);\n                \n                // Removed text feedback button since comments are now handled in star rating modals\n                \n                await user.user.send({\n                    content: `üé´ **Your Support Ticket Transcript**\\n\\n` +\n                            `Hello ${user.user.username}! Your support ticket has been closed.\\n\\n` +\n                            `**Ticket Details:**\\n` +\n                            `‚Ä¢ **Ticket ID:** ${ticket.id}\\n` +\n                            `‚Ä¢ **Category:** ${categoryInfo ? categoryInfo.label : 'Unknown'} ${categoryInfo ? categoryInfo.emoji : ''}\\n` +\n                            `‚Ä¢ **Closed by:** ${member.user.tag}\\n` +\n                            `‚Ä¢ **Date:** ${new Date().toLocaleDateString()}\\n\\n` +\n                            `üìé **Attached:** Complete conversation transcript\\n\\n` +\n                            `üí≠ **How was our support?** Please rate your experience:\\n\\n` +\n                            `Thank you for using PCRP Support! If you need further assistance, feel free to create a new ticket.`,\n                    files: [userAttachment],\n                    components: [feedbackRow]\n                });\n                \n                console.log(`Transcript DM sent successfully to ${user.user.tag}`);\n            } catch (dmError) {\n                console.log(`Could not send transcript DM to ${user.user.tag}: ${dmError.message}`);\n                // Try to inform in logs channel that DM failed\n                if (logsChannel) {\n                    try {\n                        await logsChannel.send({\n                            content: `‚ö†Ô∏è **DM Failed** - Could not send transcript to ${user.toString()}: ${dmError.message}`\n                        });\n                    } catch (logError) {\n                        console.log('Failed to log DM error:', logError.message);\n                    }\n                }\n            }\n        }\n        \n        // Delete channel after a short delay\n        setTimeout(async () => {\n            try {\n                await channel.delete();\n                console.log(`Ticket channel ${channel.name} deleted`);\n                \n                // Clean up HTML file after sending\n                if (fs.existsSync(filePath)) {\n                    fs.unlinkSync(filePath);\n                    console.log(`Cleaned up transcript file: ${fileName}`);\n                }\n            } catch (error) {\n                console.error('Error deleting ticket channel:', error);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('Error closing ticket:', error);\n        if (!interaction.replied && !interaction.deferred) {\n            try {\n                await interaction.reply({\n                    content: '‚ùå An error occurred while closing the ticket.',\n                    ephemeral: true\n                });\n            } catch (replyError) {\n                console.error('Could not send error reply:', replyError);\n            }\n        } else {\n            try {\n                await interaction.followUp({\n                    content: '‚ùå An error occurred while closing the ticket.',\n                    ephemeral: true\n                });\n            } catch (followUpError) {\n                console.error('Could not send follow up message:', followUpError);\n            }\n        }\n    }\n}\n\nasync function reconnectToTickets(client, guild) {\n    try {\n        console.log('Starting comprehensive ticket reconnection...');\n        \n        // Step 1: Get all open tickets from database\n        const openTickets = await getAllOpenTickets();\n        console.log(`Found ${openTickets.length} open tickets in database`);\n        \n        // Step 2: Get all pcrp- channels from Discord\n        const ticketChannels = guild.channels.cache.filter(channel => \n            channel.name.startsWith('pcrp-') && channel.type === 0 // Text channel\n        );\n        console.log(`Found ${ticketChannels.size} pcrp- channels in Discord`);\n        \n        let reconnectedCount = 0;\n        let createdCount = 0;\n        let closedCount = 0;\n        \n        // Step 3: Process database tickets and match with Discord channels\n        for (const ticket of openTickets) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channel_id);\n                if (!channel) {\n                    // Channel doesn't exist, mark ticket as closed\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed orphaned ticket: ${ticket.id} (channel deleted)`);\n                    closedCount++;\n                    continue;\n                }\n                \n                // Verify channel is still a valid ticket\n                if (!channel.name.startsWith('pcrp-')) {\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed invalid ticket: ${ticket.id} (wrong format)`);\n                    closedCount++;\n                    continue;\n                }\n                \n                reconnectedCount++;\n                console.log(`‚úÖ Reconnected: ${ticket.id} -> ${channel.name}`);\n            } catch (error) {\n                console.error(`Error processing ticket ${ticket.id}:`, error);\n                await closeTicket(ticket.channel_id);\n                closedCount++;\n            }\n        }\n        \n        // Step 4: Find Discord channels that don't have open database records\n        for (const [channelId, channel] of ticketChannels) {\n            try {\n                const existingOpenTicket = await getTicket(channelId).catch(() => null);\n                if (!existingOpenTicket) {\n                    // Check if there's any ticket record (even closed)\n                    const anyTicket = await getAnyTicket(channelId).catch(() => null);\n                    \n                    if (anyTicket) {\n                        // Ticket exists but is closed - reopen it\n                        await reopenTicket(channelId);\n                        console.log(`üîÑ Reopened ticket: ${anyTicket.id} -> ${channel.name}`);\n                        reconnectedCount++;\n                    } else {\n                        // Check if ticket exists by ID (different channel)\n                        const ticketId = channel.name;\n                        const ticketById = await getTicketById(ticketId).catch(() => null);\n                        \n                        if (ticketById) {\n                            // Ticket exists but wrong channel - update channel ID\n                            const stmt = db.prepare(`\n                                UPDATE tickets SET channel_id = ?, status = 'open', closed_at = NULL \n                                WHERE id = ?\n                            `);\n                            \n                            await new Promise((resolve, reject) => {\n                                stmt.run([channelId, ticketId], function(err) {\n                                    if (err) reject(err);\n                                    else resolve(this.changes > 0);\n                                });\n                                stmt.finalize();\n                            });\n                            \n                            console.log(`üîÑ Updated ticket channel: ${ticketId} -> ${channelId}`);\n                            reconnectedCount++;\n                        } else {\n                            // Completely new channel - create database record\n                            const ticketId = channel.name;\n                            \n                            // Try to extract user ID from channel topic\n                            let userId = null;\n                            let category = 'general_query';\n                            \n                            if (channel.topic) {\n                                const topicMatch = channel.topic.match(/\\((\\d+)\\)/);\n                                if (topicMatch) {\n                                    userId = topicMatch[1];\n                                }\n                                \n                                // Try to extract category from topic\n                                const categoryMatch = channel.topic.match(/Category: (.+)/);\n                                if (categoryMatch) {\n                                    const categoryLabel = categoryMatch[1].toLowerCase();\n                                    const categoryKey = Object.keys(TICKET_CATEGORIES).find(key => \n                                        TICKET_CATEGORIES[key].label.toLowerCase() === categoryLabel\n                                    );\n                                    if (categoryKey) {\n                                        category = categoryKey;\n                                    }\n                                }\n                            }\n                            \n                            if (userId) {\n                                try {\n                                    await createTicketDB(ticketId, channelId, userId, category);\n                                    console.log(`üÜï Created database record: ${ticketId}`);\n                                    createdCount++;\n                                    reconnectedCount++;\n                                } catch (createError) {\n                                    if (createError.message.includes('UNIQUE constraint')) {\n                                        console.log(`‚ö†Ô∏è Ticket ID ${ticketId} already exists, skipping creation`);\n                                    } else {\n                                        throw createError;\n                                    }\n                                }\n                            } else {\n                                console.log(`‚ö†Ô∏è Could not determine user for channel ${channel.name}`);\n                            }\n                        }\n                    }\n                }\n            } catch (error) {\n                console.error(`Error processing channel ${channel.name}:`, error);\n            }\n        }\n        \n        console.log(`\\nüìä Reconnection Summary:`);\n        console.log(`‚úÖ Reconnected: ${reconnectedCount} tickets`);\n        console.log(`üÜï Created: ${createdCount} database records`);\n        console.log(`‚ùå Closed: ${closedCount} orphaned tickets`);\n        console.log(`üìç Total active: ${reconnectedCount} tickets\\n`);\n        \n    } catch (error) {\n        console.error('Error during ticket reconnection:', error);\n    }\n}\n\nasync function handleTicketCreation(interaction) {\n    try {\n        const category = interaction.values[0];\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has an open ticket (updated for pcrp- format)\n        const existingTickets = guild.channels.cache.filter(channel => \n            channel.name.startsWith('pcrp-') && \n            channel.topic && \n            channel.topic.includes(user.id)\n        );\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        if (existingTickets.size > 0) {\n            return await interaction.editReply({\n                content: '‚ùå You already have an open ticket! Please close your existing ticket before creating a new one.'\n            });\n        }\n        \n        const ticket = await createTicket(guild, user, category);\n        \n        if (ticket) {\n            await interaction.editReply({\n                content: `‚úÖ Your ticket has been created! Please check ${ticket.toString()}`\n            });\n        } else {\n            await interaction.editReply({\n                content: '‚ùå Failed to create ticket. Please try again or contact an administrator.'\n            });\n        }\n    } catch (error) {\n        console.error('Ticket creation error:', error);\n        if (interaction.deferred && !interaction.replied) {\n            await interaction.editReply({\n                content: '‚ùå An error occurred while creating your ticket.'\n            });\n        } else if (!interaction.replied) {\n            await interaction.reply({\n                content: '‚ùå An error occurred while creating your ticket.',\n                ephemeral: true\n            });\n        }\n    }\n}\n\nasync function handleTicketTransfer(interaction) {\n    try {\n        const newCategory = interaction.values[0];\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Get ticket from database\n        const ticket = await getTicket(channel.id);\n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        const oldCategoryInfo = TICKET_CATEGORIES[ticket.category];\n        const newCategoryInfo = TICKET_CATEGORIES[newCategory];\n        \n        if (!newCategoryInfo) {\n            return await interaction.reply({\n                content: '‚ùå Invalid category selected.',\n                ephemeral: true\n            });\n        }\n        \n        // Update ticket category in database\n        await updateTicketCategory(channel.id, newCategory);\n        \n        // Update channel topic\n        const user = await guild.members.fetch(ticket.user_id).catch(() => null);\n        const newTopic = `Ticket for ${user ? user.user.tag : 'Unknown User'} (${ticket.user_id}) - Category: ${newCategoryInfo.label}`;\n        await channel.setTopic(newTopic);\n        \n        // Generate new channel name with new category\n        const categoryShortName = {\n            'general_query': 'general',\n            'account_issues': 'account', \n            'business_ticket': 'business',\n            'membership_ticket': 'membership',\n            'staff_application': 'staff',\n            'report': 'report',\n            'billing': 'billing'\n        }[newCategory] || 'general';\n        \n        const username = user ? user.user.username : 'unknown';\n        const newChannelName = `pcrp-${username}-${categoryShortName}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        // Rename channel to reflect new category\n        await channel.setName(newChannelName);\n        \n        await interaction.reply({\n            content: `‚úÖ **Ticket Transferred Successfully**\\n\\n` +\n                    `**From:** ${oldCategoryInfo ? oldCategoryInfo.label : 'Unknown'} ${oldCategoryInfo ? oldCategoryInfo.emoji : ''}\\n` +\n                    `**To:** ${newCategoryInfo.label} ${newCategoryInfo.emoji}\\n` +\n                    `**New Channel Name:** ${newChannelName}`\n        });\n        \n        // Send notification message in the ticket\n        await channel.send({\n            content: `üîÑ **Ticket Category Changed**\\n\\n` +\n                    `This ticket has been transferred from **${oldCategoryInfo ? oldCategoryInfo.label : 'Unknown'}** to **${newCategoryInfo.label}** by ${member.toString()}.`\n        });\n        \n        console.log(`Ticket ${ticket.id} transferred from ${ticket.category} to ${newCategory} by ${member.user.tag}`);\n        \n    } catch (error) {\n        console.error('Ticket transfer error:', error);\n        await interaction.reply({\n            content: '‚ùå An error occurred while transferring the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\n// Create Discord client\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent,\n        GatewayIntentBits.GuildMembers\n    ]\n});\n\n// Initialize collections\nclient.commands = new Collection();\n\n// Load commands from files\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nconst commands = [];\nfor (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = require(filePath);\n    if ('data' in command && 'execute' in command) {\n        client.commands.set(command.data.name, command);\n        commands.push(command.data.toJSON());\n        console.log(`Loaded command: ${command.data.name}`);\n    } else {\n        console.log(`[WARNING] The command at ${filePath} is missing a required \"data\" or \"execute\" property.`);\n    }\n}\n\n// All commands are now loaded from the /commands directory\n\n// Trigger reconnection when ticket not found\nasync function autoReconnectOnError(client, channelId) {\n    try {\n        const guild = client.guilds.cache.get(config.guildId);\n        if (guild) {\n            console.log(`üîÑ Auto-reconnecting due to missing ticket: ${channelId}`);\n            await reconnectToTickets(client, guild);\n            \n            // Check if ticket is now available\n            const ticket = await getTicket(channelId).catch(() => null);\n            return ticket !== null;\n        }\n    } catch (error) {\n        console.error('Auto-reconnect on error failed:', error);\n    }\n    return false;\n}\n\n// Commands are now loaded from files above\n\n// Ready event\nclient.once(Events.ClientReady, async (client) => {\n    console.log(`Ready! Logged in as ${client.user.tag}`);\n    \n    // Register slash commands with Discord\n    try {\n        console.log('Started refreshing application (/) commands.');\n        \n        const rest = new REST().setToken(process.env.DISCORD_TOKEN);\n        await rest.put(\n            Routes.applicationGuildCommands(client.user.id, config.guildId),\n            { body: commands }\n        );\n        \n        console.log('Successfully reloaded application (/) commands.');\n    } catch (error) {\n        console.error('Error registering slash commands:', error);\n    }\n    \n    try {\n        // Get the specified guild and channels from config\n        const guild = client.guilds.cache.get(config.guildId);\n        if (!guild) {\n            console.error('Guild not found! Please check your guild ID in config');\n            return;\n        }\n        \n        const ticketChannel = guild.channels.cache.get(config.ticketChannelId);\n        if (!ticketChannel) {\n            console.error('Ticket channel not found! Please check your ticket channel ID in config');\n            return;\n        }\n        \n        // Clean up old messages and create new ticket panel\n        console.log('Setting up ticket panel...');\n        await createTicketPanel(ticketChannel, guild);\n        \n        // Reconnect to existing open tickets\n        console.log('Reconnecting to open tickets...');\n        await reconnectToTickets(client, guild);\n        \n        // Start automatic reconnection system (every 5 minutes)\n        setInterval(async () => {\n            try {\n                await reconnectToTickets(client, guild);\n            } catch (error) {\n                console.error('Auto-reconnect failed:', error);\n            }\n        }, 5 * 60 * 1000);\n        \n        console.log('Bot initialization complete!');\n        \n    } catch (error) {\n        console.error('Error during bot initialization:', error);\n    }\n});\n\n// Feedback handling functions\nasync function handleFeedback(interaction) {\n    const [prefix, rating, ticketId] = interaction.customId.split('_');\n    \n    try {\n        if (prefix === 'feedback' && rating && rating !== 'text') {\n            // Star rating feedback - show modal with rating pre-selected\n            const ratingNum = parseInt(rating);\n            \n            const modal = new ModalBuilder()\n                .setCustomId(`feedback_modal_${ticketId}_${ratingNum}`)\n                .setTitle(`Feedback - ${ratingNum}‚≠ê`);\n            \n            const commentInput = new TextInputBuilder()\n                .setCustomId('feedback_comment')\n                .setLabel('Add your comment (optional)')\n                .setPlaceholder('Share your thoughts about the support you received...')\n                .setStyle(TextInputStyle.Paragraph)\n                .setMinLength(0)\n                .setMaxLength(1000)\n                .setRequired(false);\n            \n            const firstActionRow = new ActionRowBuilder().addComponents(commentInput);\n            modal.addComponents(firstActionRow);\n            \n            await interaction.showModal(modal);\n            return; // Don't send additional response for modal\n            \n        } else if (prefix === 'feedback' && rating === 'text') {\n            // Text feedback - show modal\n            const modal = new ModalBuilder()\n                .setCustomId(`feedback_modal_${ticketId}`)\n                .setTitle('Share Your Feedback');\n                \n            const feedbackInput = new TextInputBuilder()\n                .setCustomId('feedback_comment')\n                .setLabel('How was your support experience?')\n                .setPlaceholder('Please share your thoughts about the support you received...')\n                .setStyle(TextInputStyle.Paragraph)\n                .setMinLength(10)\n                .setMaxLength(1000)\n                .setRequired(true);\n                \n            const firstActionRow = new ActionRowBuilder().addComponents(feedbackInput);\n            modal.addComponents(firstActionRow);\n            \n            await interaction.showModal(modal);\n        }\n    } catch (error) {\n        console.error('Feedback handling error:', error);\n        await interaction.reply({\n            content: '‚ùå There was an error processing your feedback. Please try again later.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function handleFeedbackModal(interaction) {\n    const customId = interaction.customId.replace('feedback_modal_', '');\n    const parts = customId.split('_');\n    const ticketId = parts.slice(0, -1).join('_'); // Everything except the last part\n    const rating = parts[parts.length - 1]; // Last part is the rating\n    const comment = interaction.fields.getTextInputValue('feedback_comment');\n    \n    try {\n        await interaction.deferReply({ ephemeral: true });\n        \n        // Save feedback to database with both rating and comment\n        const ratingNum = rating ? parseInt(rating) : null;\n        await saveFeedback(ticketId, interaction.user.id, ratingNum, comment || null);\n        \n        // Send to feedback channel\n        const feedbackChannel = client.channels.cache.get(config.feedbackChannelId);\n        if (feedbackChannel) {\n            const embed = {\n                title: '‚≠ê Customer Feedback',\n                color: ratingNum ? (ratingNum >= 4 ? 0x00ff00 : ratingNum >= 3 ? 0xffff00 : 0xff0000) : 0x0099ff,\n                fields: [\n                    { name: 'üé´ Ticket ID', value: ticketId, inline: true },\n                    { name: 'üë§ User', value: interaction.user.tag, inline: true }\n                ],\n                timestamp: new Date(),\n                footer: { text: 'PCRP Support Feedback System' }\n            };\n            \n            if (ratingNum) {\n                embed.fields.push({ name: '‚≠ê Rating', value: `${ratingNum}/5 stars`, inline: true });\n            }\n            \n            if (comment && comment.trim()) {\n                embed.fields.push({ \n                    name: 'üí¨ Comment', \n                    value: comment.length > 1000 ? comment.substring(0, 997) + '...' : comment, \n                    inline: false \n                });\n            }\n            \n            await feedbackChannel.send({ embeds: [embed] });\n        }\n        \n        let responseMessage = '‚úÖ Thank you for your feedback!';\n        if (ratingNum) {\n            responseMessage += `\\n\\n**Rating:** ${ratingNum}/5 stars`;\n        }\n        if (comment && comment.trim()) {\n            responseMessage += `\\n**Your comment:** ${comment}`;\n        }\n        responseMessage += '\\n\\nWe appreciate your time and will use this feedback to improve our service.';\n        \n        await interaction.editReply({\n            content: responseMessage\n        });\n        \n    } catch (error) {\n        console.error('Feedback modal handling error:', error);\n        if (interaction.deferred) {\n            await interaction.editReply({\n                content: '‚ùå There was an error saving your feedback. Please try again later.'\n            });\n        } else {\n            await interaction.reply({\n                content: '‚ùå There was an error saving your feedback. Please try again later.',\n                ephemeral: true\n            });\n        }\n    }\n}\n\n// Auto-response system\nasync function sendAutoResponse(channel, user, category) {\n    const autoResponses = {\n        'general_query': `üëã Welcome ${user.toString()}! How can we assist you today?`,\n        'account_issues': `üëã Hi ${user.toString()}, please describe your account problem (include username, email, or any proof if needed).`,\n        'business_ticket': `üíº Hello ${user.toString()}, please provide details about your business inquiry so our team can review it.`,\n        'membership_ticket': `üëë Hi ${user.toString()}, please share your membership details or questions so we can assist you.`,\n        'staff_application': `üìù Welcome ${user.toString()}! Please provide your details (Name, Age, Experience, and why you'd like to join our team).`,\n        'report': `‚ö†Ô∏è Hello ${user.toString()}, please provide details about the issue or user you are reporting.\\n‚ÑπÔ∏è Include names, IDs, screenshots, or any proof to help us review it quickly.`,\n        'billing': `üí≥ Hi ${user.toString()}, please explain your billing/payment issue üßæ.\\nRemember: since your payment is an investment to the server, we follow a no refund policy for all purchases.`\n    };\n    \n    const response = autoResponses[category];\n    if (response) {\n        setTimeout(async () => {\n            try {\n                // Check if bot has already sent a message in this channel to avoid duplicates\n                const recentMessages = await channel.messages.fetch({ limit: 10 });\n                const botMessages = recentMessages.filter(msg => msg.author.bot && msg.author.id === client.user.id);\n                \n                // Only send if no bot message exists or the last bot message is older than 30 seconds\n                const shouldSend = botMessages.size === 0 || \n                    (Date.now() - botMessages.first().createdTimestamp) > 30000;\n                \n                if (shouldSend) {\n                    await channel.send({\n                        content: response\n                    });\n                }\n            } catch (error) {\n                console.error('Error sending auto-response:', error);\n            }\n        }, 2000); // 2 second delay\n    }\n}\n\n// Track user keyword responses to prevent repeats\nconst userKeywordResponses = new Map();\n\n// Keyword detection system with per-user response tracking\nasync function handleKeywordResponse(message) {\n    const content = message.content.toLowerCase();\n    const userId = message.author.id;\n    const channelId = message.channel.id;\n    \n    // Create unique key for user + channel + keyword type\n    let keywordType = null;\n    if (content.includes('paypal')) keywordType = 'paypal';\n    else if (content.includes('upi')) keywordType = 'upi';\n    else if (content.includes('refund')) keywordType = 'refund';\n    else if (content.includes('item missing') || content.includes('inventory') || content.includes('missing item') || \n             content.includes('lost item') || content.includes('bug report') || content.includes('report bug')) {\n        keywordType = 'missing_item';\n    }\n    \n    // If no keyword matched, return\n    if (!keywordType) return;\n    \n    const responseKey = `${userId}_${channelId}_${keywordType}`;\n    \n    // Check if user already received this type of response in this channel\n    if (userKeywordResponses.has(responseKey)) {\n        return; // Don't respond again\n    }\n    \n    // Mark that this user has received this response\n    userKeywordResponses.set(responseKey, Date.now());\n    \n    // Send appropriate response based on keyword type\n    try {\n        if (keywordType === 'paypal') {\n            await message.reply('üí≥ **PayPal Payment Link:**\\nhttps://paypal.me/DavidBarma');\n        } else if (keywordType === 'upi') {\n            await message.reply('üí≥ **UPI Payment ID:**\\ndavidbarma9-4@okicici');\n        } else if (keywordType === 'refund') {\n            await message.reply({\n                embeds: [{\n                    title: '‚ö†Ô∏è No Refund Policy',\n                    description: 'All payments made are considered an investment into the server.\\nOnce a purchase is completed, refunds will not be provided under any circumstances.',\n                    color: 0xff0000,\n                    footer: { text: 'PCRP Support Policy' }\n                }]\n            });\n        } else if (keywordType === 'missing_item') {\n            await message.reply('üìã **Please provide all the necessary details or proof (POV) so we can review your issue properly.**\\n\\n' +\n                               '**Include:**\\n' +\n                               '‚Ä¢ Screenshots or video proof\\n' +\n                               '‚Ä¢ Detailed description of the issue\\n' +\n                               '‚Ä¢ Your username/ID\\n' +\n                               '‚Ä¢ When it happened\\n' +\n                               '‚Ä¢ Any error messages you received');\n        }\n    } catch (error) {\n        console.error('Error sending keyword response:', error);\n        // Remove the tracking if sending failed\n        userKeywordResponses.delete(responseKey);\n    }\n}\n\n// Message event for keyword detection\nclient.on(Events.MessageCreate, async (message) => {\n    // Ignore bot messages\n    if (message.author.bot) return;\n    \n    // Only check messages in ticket channels\n    const ticket = await getTicket(message.channel.id).catch(() => null);\n    if (!ticket) return;\n    \n    // Handle keyword responses\n    await handleKeywordResponse(message);\n});\n\n// Interaction event\nclient.on(Events.InteractionCreate, async (interaction) => {\n    try {\n        // Handle slash commands\n        if (interaction.isChatInputCommand()) {\n            const command = client.commands.get(interaction.commandName);\n            \n            if (!command) {\n                console.error(`No command matching ${interaction.commandName} was found.`);\n                return;\n            }\n            \n            await command.execute(interaction);\n        }\n        \n        // Handle select menu interactions\n        else if (interaction.isStringSelectMenu()) {\n            if (interaction.customId === 'ticket_category') {\n                await handleTicketCreation(interaction);\n            } else if (interaction.customId === 'transfer_category') {\n                await handleTicketTransfer(interaction);\n            }\n        }\n        \n        // Handle button interactions\n        else if (interaction.isButton()) {\n            if (interaction.customId === 'claim_ticket') {\n                await handleTicketClaim(interaction);\n            } else if (interaction.customId === 'close_ticket') {\n                await handleTicketClose(interaction);\n            } else if (interaction.customId.startsWith('feedback_')) {\n                await handleFeedback(interaction);\n            }\n        }\n        \n        // Handle modal submissions\n        else if (interaction.isModalSubmit()) {\n            if (interaction.customId.startsWith('feedback_modal_')) {\n                await handleFeedbackModal(interaction);\n            }\n        }\n    } catch (error) {\n        console.error('Interaction error:', error);\n        \n        const errorMessage = 'There was an error while executing this interaction!';\n        \n        if (interaction.replied || interaction.deferred) {\n            await interaction.followUp({ content: errorMessage, ephemeral: true });\n        } else {\n            await interaction.reply({ content: errorMessage, ephemeral: true });\n        }\n    }\n});\n\n// Initialize database\ninitializeDatabase().then(() => {\n    console.log('Database initialized successfully');\n}).catch(error => {\n    console.error('Failed to initialize database:', error);\n    process.exit(1);\n});\n\n// Error handling\nclient.on('error', error => {\n    console.error('Discord client error:', error);\n});\n\nprocess.on('unhandledRejection', error => {\n    console.error('Unhandled promise rejection:', error);\n});\n\nprocess.on('uncaughtException', error => {\n    console.error('Uncaught exception:', error);\n    process.exit(1);\n});\n\n// Login to Discord\nif (!DISCORD_TOKEN || DISCORD_TOKEN === \"YOUR_DISCORD_BOT_TOKEN_HERE\") {\n    console.error('Please replace DISCORD_TOKEN with your actual Discord bot token in index.js');\n    process.exit(1);\n}\n\nclient.login(DISCORD_TOKEN).catch(error => {\n    console.error('Failed to login to Discord:', error);\n    process.exit(1);\n});","size_bytes":64628},"replit.md":{"content":"# Overview\n\nThis is a Discord ticket system bot built with Discord.js v14 and SQLite. The bot provides a comprehensive support ticket management system where users can create tickets by selecting from predefined categories, and staff members can claim and manage these tickets. The system includes features like automatic ticket cleanup, transcript generation, user feedback collection system, and role-based permissions.\n\n## Recent Changes (December 2024)\n- **Command Registration System**: Successfully migrated from hardcoded commands to file-based command loading with Discord API registration\n- **Slash Commands Working**: All 6 slash commands (/setup, /add, /remove, /rename, /transfer, /transferadmin) now properly registered and available in Discord\n- **Bot Connection**: Bot connects as \"PCRP TICKET#5559\" with full functionality restored\n- **One-Time Response System**: Implemented per-user keyword response tracking to prevent duplicate auto-responses\n- **Comprehensive Documentation**: Added detailed README with setup guides for AWS Linux, Windows, and Ubuntu hosting\n- **Ubuntu Deployment Guide**: Complete step-by-step Ubuntu deployment with all commands and security setup\n- **Fixed Interaction Errors**: Resolved duplicate acknowledgment issues in transferadmin and feedback systems\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\nTicket naming format: pcrp-username-category-### (simple 3-digit counter, no long timestamps)\nBot behavior: Single response only (no duplicate messages), proper feedback system handling\n\n# System Architecture\n\n## Bot Framework\nThe bot is built on Discord.js v14 with a modular architecture using:\n- **Commands system**: Slash commands loaded dynamically from the `/commands` directory\n  - `/setup` - Create ticket panel in channel\n  - `/add` - Add user to ticket\n  - `/remove` - Remove user from ticket\n  - `/rename` - Rename ticket channel\n  - `/transfer` - Move ticket to different category\n  - `/transferadmin` - Notify specific admin about ticket\n- **Events system**: Event handlers loaded from the `/events` directory for clean separation of concerns\n- **Gateway intents**: Configured for guilds, messages, message content, and members to handle ticket interactions\n\n## Database Layer\n- **SQLite database**: Local file-based storage using sqlite3 for persistent data\n- **Four main tables**:\n  - `tickets`: Stores ticket metadata (ID, channel, user, status, timestamps)\n  - `ticket_panels`: Tracks ticket creation panels in guilds\n  - `transcripts`: Stores ticket conversation history\n  - `feedback`: Stores user feedback with star ratings and comments\n- **Database initialization**: Automatic table creation on startup with proper schema\n\n## Ticket Management System\n- **Category-based tickets**: Seven predefined categories (General Support, Account Issues, Business, Membership, Staff Application, Report, Billing)\n- **Interactive UI**: Uses Discord select menus for ticket creation and buttons for ticket management\n- **Permission system**: Role-based access control using admin roles defined in config\n- **Automatic cleanup**: Configurable auto-deletion of closed tickets after specified time\n- **Transcript generation**: Conversation history saved before ticket deletion\n- **User feedback system**: Star ratings (1-5) and text comments collected when tickets close\n- **AI auto-response system**: Category-specific welcome messages and keyword detection\n- **Smart keyword detection**: Auto-replies for PayPal, UPI, refunds, and missing items\n- **DM notifications**: Transcript delivery with interactive feedback collection buttons\n\n## Configuration Management\n- **JSON-based config**: Centralized configuration for guild IDs, channel IDs, role permissions, feedback channel\n- **Environment variables**: Bot token and sensitive data stored in .env file\n- **Flexible limits**: Configurable maximum tickets per user and auto-delete timers\n- **Channel routing**: Automatic feedback routing to designated feedback channel (ID: 1407668519990067200)\n\n## Event Handling Architecture\n- **Interaction router**: Single interaction handler that routes slash commands, select menus, button interactions, and modal submissions\n- **Ready event**: Bot initialization, ticket panel setup, and reconnection to existing tickets\n- **Automatic synchronization**: Runs every 5 minutes to keep Discord channels and database in sync\n- **Real-time reconnection**: Auto-reconnects when ticket validation fails during operations\n- **Feedback system**: Star ratings open modal for comments (no required text), combined rating+comment posts\n- **Error handling**: Comprehensive try-catch blocks with proper defer/edit reply handling to prevent interaction errors\n\n## Utility Modules\n- **Embed generator**: Standardized embed creation for consistent UI/UX\n- **Ticket manager**: Core business logic for ticket lifecycle management\n- **Database abstraction**: Clean separation between database operations and bot logic\n\n# External Dependencies\n\n## Core Dependencies\n- **discord.js**: Primary Discord API wrapper for bot functionality and interactions\n- **sqlite3**: Local database storage for persistent ticket data and configuration\n\n## Runtime Dependencies\n- **Node.js**: JavaScript runtime environment (requires v16.11.0+)\n- **dotenv**: Environment variable management for secure token storage\n\n## Discord Platform Integration\n- **Discord Gateway**: Real-time event handling for user interactions\n- **Discord Slash Commands**: Modern command interface with built-in validation\n- **Discord Permissions API**: Role-based access control and channel permissions\n- **Discord Channels API**: Dynamic channel creation and management for tickets","size_bytes":5695},"commands/setup.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\nconst { createTicketPanel } = require('../utils/ticketManager');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('setup')\n        .setDescription('Setup the ticket system in this channel')\n        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),\n    \n    async execute(interaction) {\n        try {\n            await interaction.deferReply({ ephemeral: true });\n            \n            const success = await createTicketPanel(interaction.channel, interaction.guild);\n            \n            if (success) {\n                await interaction.editReply({\n                    content: '‚úÖ Ticket system has been successfully set up in this channel!'\n                });\n            } else {\n                await interaction.editReply({\n                    content: '‚ùå Failed to set up ticket system. Please try again.'\n                });\n            }\n        } catch (error) {\n            console.error('Setup command error:', error);\n            await interaction.editReply({\n                content: '‚ùå An error occurred while setting up the ticket system.'\n            });\n        }\n    }\n};\n","size_bytes":1217},"database/database.js":{"content":"const sqlite3 = require('sqlite3').verbose();\nconst path = require('path');\n\nconst dbPath = path.join(__dirname, 'tickets.db');\nlet db = null;\n\nfunction initializeDatabase() {\n    return new Promise((resolve, reject) => {\n        db = new sqlite3.Database(dbPath, (err) => {\n            if (err) {\n                console.error('Error opening database:', err);\n                reject(err);\n                return;\n            }\n            \n            console.log('Connected to SQLite database');\n            \n            // Create tables if they don't exist\n            db.serialize(() => {\n                // Tickets table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS tickets (\n                        id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        user_id TEXT NOT NULL,\n                        category TEXT NOT NULL,\n                        claimed_by TEXT DEFAULT NULL,\n                        status TEXT DEFAULT 'open',\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n                        closed_at DATETIME DEFAULT NULL\n                    )\n                `);\n                \n                // Ticket panels table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS ticket_panels (\n                        guild_id TEXT PRIMARY KEY,\n                        channel_id TEXT NOT NULL,\n                        message_id TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n                \n                // Transcripts table\n                db.run(`\n                    CREATE TABLE IF NOT EXISTS transcripts (\n                        ticket_id TEXT PRIMARY KEY,\n                        content TEXT NOT NULL,\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                `);\n            });\n            \n            resolve();\n        });\n    });\n}\n\nfunction getDatabase() {\n    return db;\n}\n\n// Ticket operations\nfunction createTicket(ticketId, channelId, userId, category) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT INTO tickets (id, channel_id, user_id, category)\n            VALUES (?, ?, ?, ?)\n        `);\n        \n        stmt.run([ticketId, channelId, userId, category], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM tickets WHERE channel_id = ? AND status = 'open'\n        `, [channelId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\nfunction getAllOpenTickets() {\n    return new Promise((resolve, reject) => {\n        db.all(`\n            SELECT * FROM tickets WHERE status = 'open'\n        `, [], (err, rows) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(rows);\n            }\n        });\n    });\n}\n\nfunction claimTicket(channelId, adminId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET claimed_by = ? WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([adminId, channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction closeTicket(channelId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            UPDATE tickets SET status = 'closed', closed_at = CURRENT_TIMESTAMP \n            WHERE channel_id = ? AND status = 'open'\n        `);\n        \n        stmt.run([channelId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.changes > 0);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\n// Panel operations\nfunction saveTicketPanel(guildId, channelId, messageId) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO ticket_panels (guild_id, channel_id, message_id)\n            VALUES (?, ?, ?)\n        `);\n        \n        stmt.run([guildId, channelId, messageId], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nfunction getTicketPanel(guildId) {\n    return new Promise((resolve, reject) => {\n        db.get(`\n            SELECT * FROM ticket_panels WHERE guild_id = ?\n        `, [guildId], (err, row) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(row);\n            }\n        });\n    });\n}\n\n// Transcript operations\nfunction saveTranscript(ticketId, content) {\n    return new Promise((resolve, reject) => {\n        const stmt = db.prepare(`\n            INSERT OR REPLACE INTO transcripts (ticket_id, content)\n            VALUES (?, ?)\n        `);\n        \n        stmt.run([ticketId, content], function(err) {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(this.lastID);\n            }\n        });\n        \n        stmt.finalize();\n    });\n}\n\nmodule.exports = {\n    initializeDatabase,\n    getDatabase,\n    createTicket,\n    getTicket,\n    getAllOpenTickets,\n    claimTicket,\n    closeTicket,\n    saveTicketPanel,\n    getTicketPanel,\n    saveTranscript\n};\n","size_bytes":5827},"events/interactionCreate.js":{"content":"const { Events, ChannelType, PermissionFlagsBits } = require('discord.js');\nconst { createTicket, handleTicketClaim, handleTicketClose } = require('../utils/ticketManager');\nconst config = require('../config.json');\n\nmodule.exports = {\n    name: Events.InteractionCreate,\n    async execute(interaction) {\n        try {\n            // Handle slash commands\n            if (interaction.isChatInputCommand()) {\n                const command = interaction.client.commands.get(interaction.commandName);\n                \n                if (!command) {\n                    console.error(`No command matching ${interaction.commandName} was found.`);\n                    return;\n                }\n                \n                await command.execute(interaction);\n            }\n            \n            // Handle select menu interactions\n            else if (interaction.isStringSelectMenu()) {\n                if (interaction.customId === 'ticket_category') {\n                    await handleTicketCreation(interaction);\n                }\n            }\n            \n            // Handle button interactions\n            else if (interaction.isButton()) {\n                if (interaction.customId === 'claim_ticket') {\n                    await handleTicketClaim(interaction);\n                } else if (interaction.customId === 'close_ticket') {\n                    await handleTicketClose(interaction);\n                }\n            }\n        } catch (error) {\n            console.error('Interaction error:', error);\n            \n            const errorMessage = 'There was an error while executing this interaction!';\n            \n            if (interaction.replied || interaction.deferred) {\n                await interaction.followUp({ content: errorMessage, ephemeral: true });\n            } else {\n                await interaction.reply({ content: errorMessage, ephemeral: true });\n            }\n        }\n    }\n};\n\nasync function handleTicketCreation(interaction) {\n    try {\n        const category = interaction.values[0];\n        const guild = interaction.guild;\n        const user = interaction.user;\n        \n        // Check if user already has an open ticket\n        const existingTickets = guild.channels.cache.filter(channel => \n            channel.name.startsWith('ticket-') && \n            channel.topic && \n            channel.topic.includes(user.id)\n        );\n        \n        if (existingTickets.size > 0) {\n            return await interaction.reply({\n                content: '‚ùå You already have an open ticket! Please close your existing ticket before creating a new one.',\n                ephemeral: true\n            });\n        }\n        \n        await interaction.deferReply({ ephemeral: true });\n        \n        const ticket = await createTicket(guild, user, category);\n        \n        if (ticket) {\n            await interaction.editReply({\n                content: `‚úÖ Your ticket has been created! Please check ${ticket.toString()}`\n            });\n        } else {\n            await interaction.editReply({\n                content: '‚ùå Failed to create ticket. Please try again or contact an administrator.'\n            });\n        }\n    } catch (error) {\n        console.error('Ticket creation error:', error);\n        await interaction.editReply({\n            content: '‚ùå An error occurred while creating your ticket.'\n        });\n    }\n}\n","size_bytes":3378},"events/ready.js":{"content":"const { Events } = require('discord.js');\nconst { createTicketPanel, reconnectToTickets } = require('../utils/ticketManager');\nconst config = require('../config.json');\n\nmodule.exports = {\n    name: Events.ClientReady,\n    once: true,\n    async execute(client) {\n        console.log(`Ready! Logged in as ${client.user.tag}`);\n        \n        try {\n            // Get the specified guild and channels from config\n            const guild = client.guilds.cache.get(config.guildId);\n            if (!guild) {\n                console.error('Guild not found! Please check your guild ID in config.json');\n                return;\n            }\n            \n            const ticketChannel = guild.channels.cache.get(config.ticketChannelId);\n            if (!ticketChannel) {\n                console.error('Ticket channel not found! Please check your ticket channel ID in config.json');\n                return;\n            }\n            \n            // Clean up old messages and create new ticket panel\n            console.log('Setting up ticket panel...');\n            await createTicketPanel(ticketChannel, guild);\n            \n            // Reconnect to existing open tickets\n            console.log('Reconnecting to open tickets...');\n            await reconnectToTickets(client, guild);\n            \n            console.log('Bot initialization complete!');\n            \n        } catch (error) {\n            console.error('Error during bot initialization:', error);\n        }\n    }\n};\n","size_bytes":1483},"utils/embeds.js":{"content":"const { EmbedBuilder } = require('discord.js');\n\nfunction createTicketPanelEmbed() {\n    return new EmbedBuilder()\n        .setTitle('Select Menus')\n        .setDescription('**Support Tickets**\\n\\nSelect the option that best fits your problem. A support ticket will be created for you automatically.')\n        .setColor(0x5865F2)\n        .setTimestamp();\n}\n\nfunction createTicketEmbed(user, categoryInfo) {\n    return new EmbedBuilder()\n        .setTitle(`üé´ New Ticket - ${categoryInfo.label}`)\n        .setDescription(\n            `Hello ${user.toString()}!\\n\\n` +\n            `Thank you for creating a ticket. Please describe your issue in detail and our support team will assist you shortly.\\n\\n` +\n            `**Category:** ${categoryInfo.label}\\n` +\n            `**Created:** <t:${Math.floor(Date.now() / 1000)}:F>`\n        )\n        .setColor(0x00FF00)\n        .setThumbnail(user.displayAvatarURL())\n        .setTimestamp();\n}\n\nfunction createTicketControlsEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üéõÔ∏è Ticket Controls')\n        .setDescription(\n            '**For Support Staff:**\\n' +\n            'üî∑ Click **Claim Ticket** to assign yourself to this ticket\\n' +\n            'üî∑ Click **Close Ticket** to close and archive this ticket\\n\\n' +\n            '**For Ticket Creator:**\\n' +\n            'üî∑ You can also close your own ticket using the **Close Ticket** button'\n        )\n        .setColor(0x0099FF)\n        .setTimestamp();\n}\n\nfunction createClaimedEmbed(admin) {\n    return new EmbedBuilder()\n        .setTitle('‚úÖ Ticket Claimed')\n        .setDescription(`This ticket has been claimed by ${admin.toString()}`)\n        .setColor(0xFFFF00)\n        .setTimestamp();\n}\n\nfunction createClosedEmbed() {\n    return new EmbedBuilder()\n        .setTitle('üîí Ticket Closed')\n        .setDescription('This ticket has been closed and will be deleted shortly.')\n        .setColor(0xFF0000)\n        .setTimestamp();\n}\n\nmodule.exports = {\n    createTicketPanelEmbed,\n    createTicketEmbed,\n    createTicketControlsEmbed,\n    createClaimedEmbed,\n    createClosedEmbed\n};\n","size_bytes":2108},"utils/ticketManager.js":{"content":"const { ChannelType, PermissionFlagsBits, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');\nconst { createTicket: dbCreateTicket, getTicket, claimTicket, closeTicket, saveTicketPanel, getAllOpenTickets, saveTranscript } = require('../database/database');\nconst { createTicketEmbed, createTicketControlsEmbed, createTicketPanelEmbed } = require('./embeds');\nconst config = require('../config.json');\n\n// Ticket categories mapping\nconst TICKET_CATEGORIES = {\n    'general_query': {\n        label: 'General Support',\n        description: 'General questions and support',\n        emoji: 'üîß'\n    },\n    'account_issues': {\n        label: 'Account Issues',\n        description: 'Problems with your account',\n        emoji: 'üìß'\n    },\n    'business_ticket': {\n        label: 'Business Ticket',\n        description: 'Business-related inquiries',\n        emoji: 'üíº'\n    },\n    'membership_ticket': {\n        label: 'Membership Ticket',\n        description: 'Membership support and questions',\n        emoji: 'üëë'\n    },\n    'staff_application': {\n        label: 'Staff Application',\n        description: 'Apply to join our staff team',\n        emoji: 'üìù'\n    },\n    'report': {\n        label: 'Report',\n        description: 'Report users or issues',\n        emoji: '‚ö†Ô∏è'\n    },\n    'billing': {\n        label: 'Billing Support',\n        description: 'Payment and billing issues',\n        emoji: 'üí≥'\n    }\n};\n\nasync function createTicketPanel(channel, guild) {\n    try {\n        // Clear existing messages in the channel\n        const messages = await channel.messages.fetch({ limit: 100 });\n        if (messages.size > 0) {\n            await channel.bulkDelete(messages).catch(console.error);\n        }\n        \n        // Create select menu options\n        const options = Object.entries(TICKET_CATEGORIES).map(([value, category]) => ({\n            label: category.label,\n            description: category.description,\n            value: value,\n            emoji: category.emoji\n        }));\n        \n        const selectMenu = new StringSelectMenuBuilder()\n            .setCustomId('ticket_category')\n            .setPlaceholder('Select the option that best fits your problem...')\n            .addOptions(options);\n        \n        const row = new ActionRowBuilder()\n            .addComponents(selectMenu);\n        \n        const embed = createTicketPanelEmbed();\n        \n        const message = await channel.send({\n            embeds: [embed],\n            components: [row]\n        });\n        \n        // Save panel info to database\n        await saveTicketPanel(guild.id, channel.id, message.id);\n        \n        console.log('Ticket panel created successfully');\n        return true;\n    } catch (error) {\n        console.error('Error creating ticket panel:', error);\n        return false;\n    }\n}\n\nasync function createTicket(guild, user, category) {\n    try {\n        const categoryInfo = TICKET_CATEGORIES[category];\n        if (!categoryInfo) {\n            throw new Error('Invalid ticket category');\n        }\n        \n        // Generate unique ticket ID\n        const ticketId = `ticket-${user.username}-${Date.now()}`.toLowerCase().replace(/[^a-z0-9-]/g, '');\n        \n        // Get admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        \n        // Create ticket channel\n        const ticketChannel = await guild.channels.create({\n            name: ticketId,\n            type: ChannelType.GuildText,\n            topic: `Ticket for ${user.tag} (${user.id}) - Category: ${categoryInfo.label}`,\n            permissionOverwrites: [\n                {\n                    id: guild.roles.everyone,\n                    deny: [PermissionFlagsBits.ViewChannel]\n                },\n                {\n                    id: user.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.SendMessages,\n                        PermissionFlagsBits.ReadMessageHistory\n                    ]\n                },\n                ...(adminRole ? [{\n                    id: adminRole.id,\n                    allow: [\n                        PermissionFlagsBits.ViewChannel,\n                        PermissionFlagsBits.SendMessages,\n                        PermissionFlagsBits.ReadMessageHistory,\n                        PermissionFlagsBits.ManageMessages\n                    ]\n                }] : [])\n            ]\n        });\n        \n        // Create ticket controls\n        const claimButton = new ButtonBuilder()\n            .setCustomId('claim_ticket')\n            .setLabel('Claim Ticket')\n            .setStyle(ButtonStyle.Primary)\n            .setEmoji('üëã');\n        \n        const closeButton = new ButtonBuilder()\n            .setCustomId('close_ticket')\n            .setLabel('Close Ticket')\n            .setStyle(ButtonStyle.Danger)\n            .setEmoji('üîí');\n        \n        const controlRow = new ActionRowBuilder()\n            .addComponents(claimButton, closeButton);\n        \n        // Send ticket message\n        const ticketEmbed = createTicketEmbed(user, categoryInfo);\n        const controlsEmbed = createTicketControlsEmbed();\n        \n        await ticketChannel.send({\n            content: `${user.toString()}${adminRole ? ` ${adminRole.toString()}` : ''}`,\n            embeds: [ticketEmbed, controlsEmbed],\n            components: [controlRow]\n        });\n        \n        // Save ticket to database\n        await dbCreateTicket(ticketId, ticketChannel.id, user.id, category);\n        \n        console.log(`Ticket created: ${ticketId} for user ${user.tag}`);\n        return ticketChannel;\n    } catch (error) {\n        console.error('Error creating ticket:', error);\n        return null;\n    }\n}\n\nasync function handleTicketClaim(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        if (!adminRole || !member.roles.cache.has(adminRole.id)) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to claim tickets.',\n                ephemeral: true\n            });\n        }\n        \n        // Get ticket from database\n        const ticket = await getTicket(channel.id);\n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        if (ticket.claimed_by) {\n            const claimedUser = await guild.members.fetch(ticket.claimed_by).catch(() => null);\n            return await interaction.reply({\n                content: `‚ùå This ticket is already claimed by ${claimedUser ? claimedUser.toString() : 'another admin'}.`,\n                ephemeral: true\n            });\n        }\n        \n        // Claim the ticket\n        await claimTicket(channel.id, member.id);\n        \n        await interaction.reply({\n            content: `‚úÖ ${member.toString()} has claimed this ticket!`\n        });\n        \n        console.log(`Ticket ${ticket.id} claimed by ${member.user.tag}`);\n    } catch (error) {\n        console.error('Error claiming ticket:', error);\n        await interaction.reply({\n            content: '‚ùå An error occurred while claiming the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function handleTicketClose(interaction) {\n    try {\n        const guild = interaction.guild;\n        const member = interaction.member;\n        const channel = interaction.channel;\n        \n        // Check if user has admin role or is the ticket creator\n        const adminRole = guild.roles.cache.get(config.adminRoleId);\n        const ticket = await getTicket(channel.id);\n        \n        if (!ticket) {\n            return await interaction.reply({\n                content: '‚ùå This is not a valid ticket channel.',\n                ephemeral: true\n            });\n        }\n        \n        const isAdmin = adminRole && member.roles.cache.has(adminRole.id);\n        const isTicketCreator = ticket.user_id === member.id;\n        \n        if (!isAdmin && !isTicketCreator) {\n            return await interaction.reply({\n                content: '‚ùå You do not have permission to close this ticket.',\n                ephemeral: true\n            });\n        }\n        \n        await interaction.reply({\n            content: 'üîí Closing ticket and saving transcript...'\n        });\n        \n        // Generate transcript\n        const messages = await channel.messages.fetch({ limit: 100 });\n        const transcript = messages.reverse().map(msg => \n            `[${msg.createdAt.toISOString()}] ${msg.author.tag}: ${msg.content}`\n        ).join('\\n');\n        \n        // Save transcript\n        await saveTranscript(ticket.id, transcript);\n        \n        // Close ticket in database\n        await closeTicket(channel.id);\n        \n        // Send transcript to logs channel if configured\n        const logsChannel = guild.channels.cache.get(config.logsChannelId);\n        if (logsChannel) {\n            const user = await guild.members.fetch(ticket.user_id).catch(() => null);\n            const claimedBy = ticket.claimed_by ? await guild.members.fetch(ticket.claimed_by).catch(() => null) : null;\n            \n            await logsChannel.send({\n                content: `**Ticket Closed**\\n` +\n                        `**Ticket ID:** ${ticket.id}\\n` +\n                        `**Created by:** ${user ? user.toString() : 'Unknown User'}\\n` +\n                        `**Claimed by:** ${claimedBy ? claimedBy.toString() : 'Unclaimed'}\\n` +\n                        `**Closed by:** ${member.toString()}\\n` +\n                        `**Category:** ${ticket.category}\\n` +\n                        `**Created:** ${ticket.created_at}\\n` +\n                        `**Closed:** ${new Date().toISOString()}`\n            });\n        }\n        \n        // Delete channel after a short delay\n        setTimeout(async () => {\n            try {\n                await channel.delete();\n                console.log(`Ticket channel ${channel.name} deleted`);\n            } catch (error) {\n                console.error('Error deleting ticket channel:', error);\n            }\n        }, 5000);\n        \n    } catch (error) {\n        console.error('Error closing ticket:', error);\n        await interaction.followUp({\n            content: '‚ùå An error occurred while closing the ticket.',\n            ephemeral: true\n        });\n    }\n}\n\nasync function reconnectToTickets(client, guild) {\n    try {\n        const openTickets = await getAllOpenTickets();\n        let reconnectedCount = 0;\n        \n        for (const ticket of openTickets) {\n            try {\n                const channel = guild.channels.cache.get(ticket.channel_id);\n                if (!channel) {\n                    // Channel doesn't exist, mark ticket as closed\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed orphaned ticket: ${ticket.id}`);\n                    continue;\n                }\n                \n                // Verify channel is still a valid ticket\n                if (!channel.name.startsWith('ticket-')) {\n                    await closeTicket(ticket.channel_id);\n                    console.log(`Closed invalid ticket channel: ${ticket.id}`);\n                    continue;\n                }\n                \n                reconnectedCount++;\n                console.log(`Reconnected to ticket: ${ticket.id} in channel ${channel.name}`);\n            } catch (error) {\n                console.error(`Error reconnecting to ticket ${ticket.id}:`, error);\n                // Mark as closed if there's an error\n                await closeTicket(ticket.channel_id);\n            }\n        }\n        \n        console.log(`Reconnected to ${reconnectedCount} open tickets`);\n    } catch (error) {\n        console.error('Error during ticket reconnection:', error);\n    }\n}\n\nmodule.exports = {\n    createTicketPanel,\n    createTicket,\n    handleTicketClaim,\n    handleTicketClose,\n    reconnectToTickets,\n    TICKET_CATEGORIES\n};\n","size_bytes":12297},"commands/add.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('add')\n        .setDescription('Add a user to the current ticket')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('The user to add to the ticket')\n                .setRequired(true))\n        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),\n    \n    async execute(interaction) {\n        try {\n            const user = interaction.options.getUser('user');\n            const channel = interaction.channel;\n            \n            // Check if this is a ticket channel\n            if (!channel.name.startsWith('pcrp-')) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    flags: 64\n                });\n            }\n            \n            // Add user to channel permissions\n            await channel.permissionOverwrites.edit(user, {\n                ViewChannel: true,\n                SendMessages: true,\n                ReadMessageHistory: true\n            });\n            \n            await interaction.reply({\n                content: `‚úÖ ${user.toString()} has been added to this ticket.`,\n                flags: 64\n            });\n            \n            // Send notification in the channel\n            await channel.send(`üì® ${user.toString()} has been added to this ticket by ${interaction.user.toString()}.`);\n            \n        } catch (error) {\n            console.error('Add command error:', error);\n            await interaction.reply({\n                content: '‚ùå Failed to add user to ticket.',\n                flags: 64\n            });\n        }\n    }\n};","size_bytes":1799},"commands/remove.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('remove')\n        .setDescription('Remove a user from the current ticket')\n        .addUserOption(option =>\n            option.setName('user')\n                .setDescription('The user to remove from the ticket')\n                .setRequired(true))\n        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),\n    \n    async execute(interaction) {\n        try {\n            const user = interaction.options.getUser('user');\n            const channel = interaction.channel;\n            \n            // Check if this is a ticket channel\n            if (!channel.name.startsWith('pcrp-')) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    flags: 64\n                });\n            }\n            \n            // Remove user from channel permissions\n            await channel.permissionOverwrites.delete(user);\n            \n            await interaction.reply({\n                content: `‚úÖ ${user.toString()} has been removed from this ticket.`,\n                flags: 64\n            });\n            \n            // Send notification in the channel\n            await channel.send(`üì§ ${user.tag} has been removed from this ticket by ${interaction.user.toString()}.`);\n            \n        } catch (error) {\n            console.error('Remove command error:', error);\n            await interaction.reply({\n                content: '‚ùå Failed to remove user from ticket.',\n                flags: 64\n            });\n        }\n    }\n};","size_bytes":1699},"commands/rename.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('rename')\n        .setDescription('Rename the current ticket channel')\n        .addStringOption(option =>\n            option.setName('name')\n                .setDescription('New name for the ticket channel')\n                .setRequired(true)\n                .setMaxLength(100))\n        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),\n    \n    async execute(interaction) {\n        try {\n            const newName = interaction.options.getString('name');\n            const channel = interaction.channel;\n            \n            // Check if this is a ticket channel\n            if (!channel.name.startsWith('pcrp-')) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            const oldName = channel.name;\n            \n            // Clean the name to make it Discord-compatible\n            const cleanName = newName.toLowerCase()\n                .replace(/[^a-z0-9-]/g, '-')\n                .replace(/-+/g, '-')\n                .replace(/^-|-$/g, '');\n            \n            if (!cleanName) {\n                return await interaction.reply({\n                    content: '‚ùå Please provide a valid name for the channel.',\n                    ephemeral: true\n                });\n            }\n            \n            await channel.setName(cleanName);\n            \n            await interaction.reply({\n                content: `‚úÖ Ticket channel renamed from \\`${oldName}\\` to \\`${cleanName}\\`.`,\n                ephemeral: true\n            });\n            \n            // Send notification in the channel\n            await channel.send(`üìù This ticket has been renamed to **${cleanName}** by ${interaction.user.toString()}.`);\n            \n        } catch (error) {\n            console.error('Rename command error:', error);\n            await interaction.reply({\n                content: '‚ùå Failed to rename ticket channel.',\n                ephemeral: true\n            });\n        }\n    }\n};","size_bytes":2241},"commands/transfer.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits, StringSelectMenuBuilder, ActionRowBuilder } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('transfer')\n        .setDescription('Transfer ticket to a different category')\n        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),\n    \n    async execute(interaction) {\n        try {\n            const channel = interaction.channel;\n            \n            // Check if this is a ticket channel\n            if (!channel.name.startsWith('pcrp-')) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    ephemeral: true\n                });\n            }\n            \n            // Create category selection menu\n            const TICKET_CATEGORIES = {\n                'general_query': {\n                    label: 'General Support',\n                    description: 'General questions and support',\n                    emoji: 'üîß'\n                },\n                'account_issues': {\n                    label: 'Account Issues',\n                    description: 'Problems with your account',\n                    emoji: 'üìß'\n                },\n                'business_ticket': {\n                    label: 'Business Ticket',\n                    description: 'Business-related inquiries',\n                    emoji: 'üíº'\n                },\n                'membership_ticket': {\n                    label: 'Membership Ticket',\n                    description: 'Membership support and questions',\n                    emoji: 'üëë'\n                },\n                'staff_application': {\n                    label: 'Staff Application',\n                    description: 'Apply to join our staff team',\n                    emoji: 'üìù'\n                },\n                'report': {\n                    label: 'Report',\n                    description: 'Report users or issues',\n                    emoji: '‚ö†Ô∏è'\n                },\n                'billing': {\n                    label: 'Billing Support',\n                    description: 'Payment and billing issues',\n                    emoji: 'üí≥'\n                }\n            };\n            \n            const options = Object.entries(TICKET_CATEGORIES).map(([value, info]) => ({\n                label: info.label,\n                description: info.description,\n                value: value,\n                emoji: info.emoji\n            }));\n            \n            const selectMenu = new StringSelectMenuBuilder()\n                .setCustomId('transfer_category')\n                .setPlaceholder('Choose new category for this ticket')\n                .addOptions(options);\n            \n            const row = new ActionRowBuilder()\n                .addComponents(selectMenu);\n            \n            await interaction.reply({\n                content: 'üîÑ **Transfer Ticket**\\n\\nSelect the new category for this ticket:',\n                components: [row],\n                ephemeral: true\n            });\n            \n        } catch (error) {\n            console.error('Transfer command error:', error);\n            await interaction.reply({\n                content: '‚ùå Failed to create transfer menu.',\n                ephemeral: true\n            });\n        }\n    }\n};","size_bytes":3359},"commands/transferadmin.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('transferadmin')\n        .setDescription('Notify a specific admin about this ticket')\n        .addUserOption(option =>\n            option.setName('admin')\n                .setDescription('The admin to notify about this ticket')\n                .setRequired(true))\n        .addStringOption(option =>\n            option.setName('reason')\n                .setDescription('Reason for the admin notification')\n                .setRequired(false)\n                .setMaxLength(500))\n        .setDefaultMemberPermissions(PermissionFlagsBits.ManageChannels),\n    \n    async execute(interaction) {\n        try {\n            const admin = interaction.options.getUser('admin');\n            const reason = interaction.options.getString('reason') || 'No reason provided';\n            const channel = interaction.channel;\n            \n            // Check if this is a ticket channel\n            if (!channel.name.startsWith('pcrp-')) {\n                return await interaction.reply({\n                    content: '‚ùå This command can only be used in ticket channels.',\n                    flags: 64 // Ephemeral flag\n                });\n            }\n            \n            // Check if the mentioned user is actually an admin\n            const member = await interaction.guild.members.fetch(admin.id).catch(() => null);\n            if (!member) {\n                return await interaction.reply({\n                    content: '‚ùå Could not find that user in this server.',\n                    flags: 64 // Ephemeral flag\n                });\n            }\n            \n            // Add admin to channel permissions if not already added\n            await channel.permissionOverwrites.edit(admin, {\n                ViewChannel: true,\n                SendMessages: true,\n                ReadMessageHistory: true\n            });\n            \n            await interaction.reply({\n                content: `‚úÖ ${admin.toString()} has been notified about this ticket.`,\n                flags: 64 // Ephemeral flag\n            });\n            \n            // Send notification in the channel\n            await channel.send(`üîî **Admin Notification**\\n\\n${admin.toString()}, you have been requested to assist with this ticket by ${interaction.user.toString()}.\\n\\n**Reason:** ${reason}\\n\\nüìç This ticket requires your attention.`);\n            \n            // Try to send DM to the admin\n            try {\n                await admin.send(`üé´ **Ticket Notification**\\n\\nYou have been requested to assist with a ticket in **${interaction.guild.name}**.\\n\\n**Ticket:** ${channel.toString()}\\n**Requested by:** ${interaction.user.tag}\\n**Reason:** ${reason}\\n\\nPlease check the ticket channel for more details.`);\n            } catch (dmError) {\n                console.log(`Could not send DM to ${admin.tag}: ${dmError.message}`);\n            }\n            \n        } catch (error) {\n            console.error('Transferadmin command error:', error);\n            if (!interaction.replied && !interaction.deferred) {\n                await interaction.reply({\n                    content: '‚ùå Failed to notify admin.',\n                    flags: 64 // Ephemeral flag\n                });\n            }\n        }\n    }\n};","size_bytes":3355}}}